# Flutter 설치하기

워드 파일 따라하기

1. vscode에서 flutter 설치

2. flutter SDK 파일 사이트에서 받기

3. flutter SDK 환경변수 등록

4. 안드로이드 스튜디오에서 flutter(+ Dart) plugin 설치

5. powershell 에서 명령실행

   ```cmd
   # 제대로 설치 및 인식되었는지 확인
   flutter doctor
   # 전부 y
   flutter doctor --android-licenses
   # Unable to locate Android SDK. 라고 오류날 시 SDK 위치 지정
   flutter config --android-sdk D:\Program Files\Android\Sdk
   # 에디터 재부팅 후 flutter doctor --android-licenses 명령어 다시 실행
   ```



> Flutter support: Android Jelly Bean, v16, 4.1.x or newer, and iOS 8 or newer.

-----

# BLOC 패턴 적용하기

**BLOC 패턴**

![img](https://blog.kakaocdn.net/dn/brtfLf/btqw78Up1XE/HKDk2faxzFEVDJ21SuQbmK/img.png)

- 하나 또는 여러개의 Bloc 이 존재 할 수 있다.

- Presentation Layer 에서 비즈니스 로직을 최대한 분리하며, 그로 인해 그로인해 테스트가 용이하다.

- 플랫폼 종속적이지 않다.

- 환경에 종속적이지 않다.

n개의 입구와 m개의 출구가 있는 큐를 컨트롤하는 패턴이라고 생각하시면 됩니다

입구는 sink로 불리우고, 출구는 stream이라고 부릅니다.

입구로는 데이터를 넣고, 출구로는 데이터를 받아서 Widget을 갱신할때 많이 쓰는 패턴 입니다.

입구는 여러개일 수 있지만, 반응하는 출구는 1개로 인식되며, 출구를 여러개로 바꿀때는 broadcast를 이용합니다 

이런 입구와 출구를 관리해주고 쉽게 접근할 수 있게 해주는 클래스를 StreamController라고 합니다.

**BLoC 패턴에 대한 다른 접근 방법에 대해서는 '수지아빠' 님의 게시글을 참고하시면 됩니다**

https://javaexpert.tistory.com/970



View 에서 비즈니스 로직을 최대한 분리하고, Bloc 에서 데이터 처리를 담당하고

해당 데이터가 필요한 View 에서는 해당 stream 을 구독하여 데이터를 표시하고,

데이터의 변경이 필요할 때는 해당 Stream 으로 Sink 하여 데이터를 변경 합니다.

변경된 데이터는 해당 Stream 을 구독하고 있는 모든 View 에 전달 됩니다.

Dart 에서 RxDart 를 사용할 수 있지만, 기본적으로 다트는 Stream 을 지원하기 때문에 기본 제공되는 Stream 으로 구현 해 봅시다.

Reactive Programming 의 장점으로는 아래 글을 읽어봅시다. RX 관련 라이브러리가 Stream 기반 로직을 쉽게 작성하도록 도와주는 대표적인 라이브러리 입니다.

https://medium.com/corebuild-software/why-you-should-learn-reactive-programming-51b6ffc31425



> Dart 에서 싱글톤 클래스를 만들기 위한 방법은 기본적으로 생성자를 private 상태로 만들고 이루어 집니다. 추가로 static 변수를 활용한 제공 또는 별도의 getter 함수를 이용하는 방법, 마지막으로 Factory 를 이용하는 방법이 있습니다.
>
> FutureBuildr 위젯은 지정된 비동기 요청을 처리하여 전달받은 데이터를 이용하여 위젯을 만들고 데이터를 표현할 수 있는 위젯 입니다. Javascript 로 치면 Promise 와 같습니다.
>
> broadcast() 는 일반적으로 SingleSubscription 으로 생성되는 Controller 를 Multi Subscription 으로 변경 합니다. 한마디로 기본적으로 stream 을구독하여 데이터를 전파 받을 수 있는 건 하나지만, 이걸 여러 곳 에서 전파 받을 수 있도록변경 시킨 것 입니다.



## PART1

**새 프로젝트 만들기**

command에 new project를 검색하여  새 프로젝트 만든다.

```dart
flutter create myProjectName
```



**예제를 삭제하고 빈 페이지 만들기**

lib - main.dart에서 예제로 구현되어있는 부분을 지우고 필요한 핵심만 남긴다.

```dart
import 'package:flutter/material.dart';
import 'src/app.dart';

void main(){
  runApp(App());
}
```



**2번째줄 오류 해결**

lib - app.dart 작성하기

```dart
import 'package:flutter/material.dart';
import 'ui/movie_list.dart';

class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return MaterialApp(
        theme: ThemeData.dark(),
        home: Scaffold(
          body: MovieList(),
        ),
     );
  }
}
```



**BLOC 패턴 이용하기(MVVM)**

> BLOC 패턴이란?
>
> Google 개발자가 권장하는 Flutter의 상태 관리 시스템입니다.
>
> 프로젝트를 관리하는 데 도움이되며 프로젝트의 중앙 위치에서 데이터에 액세스 할 수 있습니다.

lib 패키지 아래에 src 패키지를 만든다.

src 안에 blocs, models, resources, ui 라는 패키지를 만들어 프로젝트의 골격을 설정한다.

![image-20200927014349434](C:\Users\kdogy\AppData\Roaming\Typora\typora-user-images\image-20200927014349434.png)

- bloc

  블록에 관련된 파일

- models

  POGO 클래스, 서버에서 얻을 JSON 응답의 모델 클래스

- resources

  repository 클래스, 네트워크 호출 구현 클래스

- ui

  사용자 화면

  

**RxDart, Http 서드파트 라이브러리 추가**

`pubspec.yaml` 파일의 dependencies 에 추가

```dart
rxdart: ^0.24.1
// 버전은 본인이 필요한 버전으로 이용
// https://pub.dev/packages/rxdart
http: ^0.12.2
// https://pub.dev/packages/http
```

추가 후 프로젝트 동기화 (VScode의 경우 저장하면 자동 동기화, 명령어는 `flutter packages get`)



**model 구현**

우선 우리는 아래와 같은 JSON 응답이 오는 API를 이용한다고 가정하자.

> TMDB의 API이용	https://www.themoviedb.org/signup
>
> http://api.themoviedb.org/3/movie/popular?api_key=<your API key>

```json
{
  "page": 1,
  "total_results": 19772,
  "total_pages": 989,
  "results": [
    {
      "vote_count": 6503,
      "id": 299536,
      "video": false,
      "vote_average": 8.3,
      "title": "Avengers: Infinity War",
      "popularity": 350.154,
      "poster_path": "\/7WsyChQLEftFiDOVTGkv3hFpyyt.jpg",
      "original_language": "en",
      "original_title": "Avengers: Infinity War",
      "genre_ids": [
        12,
        878,
        14,
        28
      ],
      "backdrop_path": "\/bOGkgRGdhrBYJSLpXaxhXVstddV.jpg",
      "adult": false,
      "overview": "As the Avengers and their allies have continued to protect the world from threats too large for any one hero to handle, a new danger has emerged from the cosmic shadows: Thanos. A despot of intergalactic infamy, his goal is to collect all six Infinity Stones, artifacts of unimaginable power, and use them to inflict his twisted will on all of reality. Everything the Avengers have fought for has led up to this moment - the fate of Earth and existence itself has never been more uncertain.",
      "release_date": "2018-04-25"
    },
```



`models - item_model.dart` 에 해당 응답을 담을 모델을 작성합니다.

```dart
class ItemModel {
  int _page;
  int _total_results;
  int _total_pages;
  List<_Result> _results = [];

  ItemModel.fromJson(Map<String, dynamic> parsedJson) {
    print(parsedJson['results'].length);
    _page = parsedJson['page'];
    _total_results = parsedJson['total_results'];
    _total_pages = parsedJson['total_pages'];
    List<_Result> temp = [];
    for (int i = 0; i < parsedJson['results'].length; i++) {
      _Result result = _Result(parsedJson['results'][i]);
      temp.add(result);
    }
    _results = temp;
  }

  List<_Result> get results => _results;

  int get total_pages => _total_pages;

  int get total_results => _total_results;

  int get page => _page;
}

class _Result {
  int _vote_count;
  int _id;
  bool _video;
  var _vote_average;
  String _title;
  double _popularity;
  String _poster_path;
  String _original_language;
  String _original_title;
  List<int> _genre_ids = [];
  String _backdrop_path;
  bool _adult;
  String _overview;
  String _release_date;

  _Result(result) {
    _vote_count = result['vote_count'];
    _id = result['id'];
    _video = result['video'];
    _vote_average = result['vote_average'];
    _title = result['title'];
    _popularity = result['popularity'];
    _poster_path = result['poster_path'];
    _original_language = result['original_language'];
    _original_title = result['original_title'];
    for (int i = 0; i < result['genre_ids'].length; i++) {
      _genre_ids.add(result['genre_ids'][i]);
    }
    _backdrop_path = result['backdrop_path'];
    _adult = result['adult'];
    _overview = result['overview'];
    _release_date = result['release_date'];
  }

  String get release_date => _release_date;

  String get overview => _overview;

  bool get adult => _adult;

  String get backdrop_path => _backdrop_path;

  List<int> get genre_ids => _genre_ids;

  String get original_title => _original_title;

  String get original_language => _original_language;

  String get poster_path => _poster_path;

  double get popularity => _popularity;

  String get title => _title;

  double get vote_average => _vote_average;

  bool get video => _video;

  int get id => _id;

  int get vote_count => _vote_count;
}
```

해당 JSON을 파싱하여 담을 클래스를 만든다. `ItemModel`

결과를 가져오는것은`get`을 이용해서만 가져올 수 있도록 한다.

또한 결과가 리스트로 들어오기에 필요한 객체를 만들어준다. `class _Result`



**네트워크 구현**

`resources - movie_api_provider.dart` 에 API통신을 할 수 있는 클래스를 구현한다.

```dart
import 'dart:async';
import 'package:http/http.dart' show Client;
import 'dart:convert';
import '../models/item_model.dart';

class MovieApiProvider {
  Client client = Client();
  final _apiKey = 'your_api_key'; // 위에서 실제 사이트에서 발급받은 API 값

  Future<ItemModel> fetchMovieList() async {
    print("entered");
    final response = await client
        .get("https://api.themoviedb.org/3/movie/popular?api_key=$_apiKey");
    print(response.body.toString());
    if (response.statusCode == 200) {
      // If the call to the server was successful, parse the JSON
      return ItemModel.fromJson(json.decode(response.body));
    } else {
      // If that call was not successful, throw an error.
      throw Exception('Failed to load post');
    }
  }
}
```

`fetchMovieList()`가 API 호출을 담당합니다.

호출이 성공할 경우 Futer ItemModel 객체를 반환합니다.

실패하면 Exception을 던집니다.



**Repository 구현**

`resources - repository.dart` 에 repository 클래스 구현

```dart
import 'dart:async';
import 'movie_api_provider.dart';
import '../models/item_model.dart';

class Repository {
  final moviesApiProvider = MovieApiProvider();

  Future<ItemModel> fetchAllMovies() => moviesApiProvider.fetchMovieList();
}
```

`movie_api_provier.dart` 라는 파일의 `fetchMovieList()`를 호출하는 repository 클래스는 데이터 BLOC으로 전달되는 중심점이다.



**BLOC 로직 구현**

`blocs - movies_bloc.dart` 에서 bloc 로직 구현

```dart
import '../resources/repository.dart';
import 'package:rxdart/rxdart.dart';
import '../models/item_model.dart';

class MoviesBloc {
  final _repository = Repository();
  final _moviesFetcher = PublishSubject<ItemModel>();

  Observable<ItemModel> get allMovies => _moviesFetcher.stream;

  fetchAllMovies() async {
    ItemModel itemModel = await _repository.fetchAllMovies();
    _moviesFetcher.sink.add(itemModel);
  }

  dispose() {
    _moviesFetcher.close();
  }
}

final bloc = MoviesBloc();
```

우리는 `import 'package:rxdart/rxdart.dart';`를 임포트 하고 있으며 이것은 이 파일 안에 모든 [RxDart](https://pub.dartlang.org/packages/rxdart) 관련 메소드와 클래스를 임포트 합니다. `MoviesBloc` 클래스 안에서 우리는 <u>`fetchAllMovies()`에 접근하는 데 사용될 `Repository` 클래스 객체</u>를 생성 합니다. 우리는 <u>`ItemModel`의 형태로 서버에서 가져온 데이터를 추가하는 책임이 있는 [`PublishSubject`](https://pub.dartlang.org/documentation/rxdart/latest/rx/PublishSubject-class.html) 객체를 생성</u>하고, UI 화면에 스트림으로 전달합니다. <u>`ItemModel` 객체를 스트림으로 전달하기 위해 반환 타입이 [`Observable`](https://youtu.be/XbOuCBuQepI) 인 `allMovies()`메서드</u>를 만들었습니다 (`Observables`를 이해하지 못한다면 이 비디오를 보세요). <u>마지막 행을 보면 `bloc` 객체가 생성됩니다. 이렇게 하면 우리는 `MoviesBloc` 클래스의 단일 인스턴스에 대한 액세스를 UI 화면에 제공합니다.</u>

***`movies_block.dart`에는 `bloc`라는 최상위 변수가 있습니다. 아키텍쳐를 새로 세워야 할 것으로 보입니다.***

반응형 프로그래밍이 무엇인지 모르는 경우 이 간단한 [설명](https://dzone.com/articles/only-introduction-reactive)을 읽어 보세요. 간단히 말하면, 서버에서 오는 새로운 데이터가 있을 때마다 간단히 반응하면 됩니다. 이 업데이트 작업을 단순화 하기 위해 우리는 `MoviesBloc` 클래스에서 발생하는 모든 변경 사항을 계속 관찰하고, 이에 따라 콘텐츠를 업데이트 하도록 UI 화면에 지시합니다. 새로운 데이터를 “관찰”하는 것은 `RxDart`를 사용하여 수행 할 수 있습니다.



**UI 구현**

`ui - movie_list.dart` 에 화면 UI 구성

```dart
import 'package:flutter/material.dart';
import '../models/item_model.dart';
import '../blocs/movies_bloc.dart';

class MovieList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    bloc.fetchAllMovies();
    return Scaffold(
      appBar: AppBar(
        title: Text('Popular Movies'),
      ),
      body: StreamBuilder(
        stream: bloc.allMovies,
        builder: (context, AsyncSnapshot<ItemModel> snapshot) {
          if (snapshot.hasData) {
            return buildList(snapshot);
          } else if (snapshot.hasError) {
            return Text(snapshot.error.toString());
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  Widget buildList(AsyncSnapshot<ItemModel> snapshot) {
    return GridView.builder(
        itemCount: snapshot.data.results.length,
        gridDelegate:
            new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),
        itemBuilder: (BuildContext context, int index) {
          return Image.network(
            'https://image.tmdb.org/t/p/w185${snapshot.data
                .results[index].poster_path}',
            fit: BoxFit.cover,
          );
        });
  }
}
```

***이 클래스에서 흥미로운 부분은 `statefulWidget`을 사용하지 않는 것입니다. 대신 StatefulWidget이 UI를 업데이트 하는 것과 동일한 작업을 수행하는 `streamBuilder`를 사용하고 있습니다.***

***`build(context)`안에서 네트워크 호출을 하는데, `build(context)`가 여러번 호출 될 수 있기 때문에 이 메소드에서 네트워크 호출하는 것은 옳지 않다. 수정이 팔요하다.***

앞에서 언급했듯이, 우리의 `MoviesBloc` 클래스는 새로운 데이터를 스트림으로 전달합니다. 따라서 스트림을 처리하기 위해 내장 클래스 즉, 들어오는 스트림을 수신하여, 이에 따라 UI를 업데이트하는 `StreamBuilder`가 있습니다. `StreamBuilder`는 `MovieBloc`의 `allMovies()` 메소드가 `stream`을 반환 할 때 전달하는 `stream` 매개 변수를 기대합니다. 따라서 `StreamBuilder`는 최신 데이터로 위젯을 다시 렌더링 합니다. 여기서 스냅샷 데이터가 `ItemModel` 객체를 가지고 있습니다. 이제 개체에 있는 모든 것을 표시 할 수 있는 위젯을 만들 수 있습니다 (여기에서 당신의 창의성이 그림에 나타납니다). `GridView`를 사용하여 `ItemModel` 객체의 결과 목록에 있는 모든 포스터를 표시했습니다.



## PART2

앞선 만든 프로젝트에서 4곳의 결함이 있다. 이 결함을 해결해 나가보자.

앞의 코드를 고쳐서 공유해도 되지만, 앞으로 앱을 만들어 나가는 과정에서 많은 문제들을 해결해 나갈 수 있으려면 고쳐진 코드보다 왜 이렇게 생각하고 어떻게 해결했는지 알아 나가는 것이 더욱 도움이 된다.

#### Topics we will cover

1. Solving the flaws in current architecture design
2. Single Instance vs Scoped Instance (BLoC access)
3. Navigation
4. RxDart’s Transformers



**1. Solving the flaws in current architecture design**

첫 번째 문제는 `MovieBloc` 클래스에서 메모리 누수를 방지하기 위해 열려있는 모든 스트림을 닫는 `dipose()`를 만들었지만 한번도 사용한 적이 없다는 것이다. 둘째, 네트워크 호출을 `build` 메소드 안에서 한다는 것이다. 

현재 `MovieList` 클래스는 `StatelessWidget` 이고 이 위젯의 작동에서 `build` 는 위젯 트리에 추가되거나 모든 속성이 변경 불가능할 때 호출됩니다. `build` 는 진입점이기에 구성이 변경되면 여러번 호출이 됩니다. 따라서 네트워크 호출을 하기에는 적절하지 않은 곳입니다. 게다가 `dispose` 를 쓰지 않았습니다. 따라서 네트워크 호출을 할 위치를 찾아내고 마지막에 `dispose` 를 호출해야 합니다.

`StatefulWidget` 은 `initState` 와 `dispose` 를 가지고 있지만 `StatelessWidget` 은 가지고 있습니다. `initState` 메소드는 리소스를 할당하기 위해 호출되고, `dispose` 메소드는 할당된 리소스를 처리하기 위해 호출됩니다. 따라서 `MovieList` 클래스를 `StatefulWidget` 으로 변경해서 `initState()` 에서 네트워크 호출하고 `dispose()` 에서 `MovieBolc's dispose()`를 호출하자. 



`movie_list.dart` 코드 바꾸기

```dart
import 'package:flutter/material.dart';
import '../models/item_model.dart';
import '../blocs/movies_bloc.dart';

class MovieList extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    return MovieListState();
  }
}

class MovieListState extends State<MovieList> {
  @override
  void initState() {
    super.initState();
    bloc.fetchAllMovies();
  }

  @override
  void dispose() {
    bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Popular Movies'),
      ),
      body: StreamBuilder(
        stream: bloc.allMovies,
        builder: (context, AsyncSnapshot<ItemModel> snapshot) {
          if (snapshot.hasData) {
            return buildList(snapshot);
          } else if (snapshot.hasError) {
            return Text(snapshot.error.toString());
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  Widget buildList(AsyncSnapshot<ItemModel> snapshot) {
    return GridView.builder(
        itemCount: snapshot.data.results.length,
        gridDelegate:
            new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),
        itemBuilder: (BuildContext context, int index) {
          return GridTile(
            child: Image.network(
              'https://image.tmdb.org/t/p/w185${snapshot.data
                  .results[index].poster_path}',
              fit: BoxFit.cover,
            ),
          );
        });
  }
}
```

`bloc.fetchAllMovies()` 를 `initState()` 에서 부르고, `bloc.dispose()` 를 `dipose()` 안에서 불렀다. 앱을 실행하면 이전과 다를 바 없이 실행되지만, 내부적으로는 네트워크함수의 다중 호출과 메모리 누수 문제가 해결되었다.

***네트워크 호출이나 DB 호출을 절대로 `build` 안에 넣으면 안된다. 또한 항상 열러 있는 스트림은 닫아줘야한다***



#### 영화 세부정보 기능 구현

**흐름도**

![](https://miro.medium.com/max/875/1*dkKlfFewf6CBVbwFIeCNHQ.png)

- Movie List Screen: 모든 영화 목록을 볼 수 있는 화면
- Movie List Bloc: 요청에 따라 저장소에서 데이터를 가져와 Movie List Screen으로 전달하는 브릿지 (Single Instance)
- Movie Detail Screen: 선택한 영화의 상세 정보를 볼 수 있는 화면  (Scoped Instance)
- Repository: 데이터 흐름 제어
- API provider: 네트워크 호출



**2. Single Instance vs Scoped Instance**

BLoC 클래스는 Single과 Scoped 두가지 방법으로 화면에 노출할 수 있습니다.

Single Instance의 경우는 BLoC 클래스의 Single reference 단일참조(Singleton)가 화면에 노출되는 것을 의미합니다. 이러한 유형의 BLoC 클래스는 앱의 모든 부분에서 접근 할 수 있습니다. 모든 화면에서 단일 인스턴트 BLoC 클래스를 사용할 수 있습니다.

하지만 Scoped Instance 는 제한된 접근을 가집니다. 관련되거나 노출된 화면에서만 접근 할 수 있습니다. 아래 사진은 Scoped Instance를 설명하는 다이어그램입니다.

![](https://miro.medium.com/max/875/1*rID6hLMzUfIwSA6m8UkM2g.png)

위 그림에서 보다시피 bloc은 Screen과 그 밑에 있는 커스텀 위젯에서만 접근이 가능합니다. 이는 BLoC을 가지고 있는 InheritedWidget을 사용하여 Screen 위젯을 감싸 Screen 위젯과 그 아래 위젯들이 BloC에 접근할 수 있도록 해주기 때문입니다. Screen Widget의 부모 위젯은 BLoC에 접근 할 수 없습니다.

소유모 앱에서는 단일 인스턴스 방식이, 대규모 앱에서는 범위 인스턴스 방식이 선호하는 방식입니다.



**Detail Screen 추가**

사용자가 영화 항목을 클릭하여야지만 Detail Screen이 보이게 됩니다. 일부 세부 사항(영화명, 등급, 개봉일, 설명, 포스터)은 List Screen에서 Detail Screen으로 전달되고, 트레일러는 서버에서 로드됩니다. 트레일러는 잠시 접어두고 List Screen에서 전달된 데이터 처리를 하겠습니다.

`ui - movie_detail.dart` 를 만듭니다.

```dart
import 'package:flutter/material.dart';

class MovieDetail extends StatefulWidget {
  final posterUrl;
  final description;
  final releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetail({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  State<StatefulWidget> createState() {
    return MovieDetailState(
      title: title,
      posterUrl: posterUrl,
      description: description,
      releaseDate: releaseDate,
      voteAverage: voteAverage,
      movieId: movieId,
    );
  }
}

class MovieDetailState extends State<MovieDetail> {
  final posterUrl;
  final description;
  final releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetailState({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        top: false,
        bottom: false,
        child: NestedScrollView(
          headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
            return <Widget>[
              SliverAppBar(
                expandedHeight: 200.0,
                floating: false,
                pinned: true,
                elevation: 0.0,
                flexibleSpace: FlexibleSpaceBar(
                    background: Image.network(
                  "https://image.tmdb.org/t/p/w500$posterUrl",
                  fit: BoxFit.cover,
                )),
              ),
            ];
          },
          body: Padding(
            padding: const EdgeInsets.all(10.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                Container(margin: EdgeInsets.only(top: 5.0)),
                Text(
                  title,
                  style: TextStyle(
                    fontSize: 25.0,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                Row(
                  children: <Widget>[
                    Icon(
                      Icons.favorite,
                      color: Colors.red,
                    ),
                    Container(
                      margin: EdgeInsets.only(left: 1.0, right: 1.0),
                    ),
                    Text(
                      voteAverage,
                      style: TextStyle(
                        fontSize: 18.0,
                      ),
                    ),
                    Container(
                      margin: EdgeInsets.only(left: 10.0, right: 10.0),
                    ),
                    Text(
                      releaseDate,
                      style: TextStyle(
                        fontSize: 18.0,
                      ),
                    ),
                  ],
                ),
                Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                Text(description),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

List Screen에서 제공되는 데이터를 저장하기위해 클래스의 생성자에서 몇 가지 필요한 변수를 생성합니다. 



**Navigator**

다른 화면으로 이동하기위해서 Navigator 클래스를 이용합니다. `movie_list.dart` 에서 탐색 로직을 구현합니다.

기본 아이디어는 목록 화면에서 특정 영화를 선택하면 상세 정보 화면을 열고 List Screen에서 전달된 내용을 표시합니다.

`movie_list.dart`

```dart
import 'package:flutter/material.dart';
import '../models/item_model.dart';
import '../blocs/movies_bloc.dart';
import 'movie_detail.dart';

class MovieList extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    return MovieListState();
  }
}

class MovieListState extends State<MovieList> {
  @override
  void initState() {
    super.initState();
    bloc.fetchAllMovies();
  }

  @override
  void dispose() {
    bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Popular Movies'),
      ),
      body: StreamBuilder(
        stream: bloc.allMovies,
        builder: (context, AsyncSnapshot<ItemModel> snapshot) {
          if (snapshot.hasData) {
            return buildList(snapshot);
          } else if (snapshot.hasError) {
            return Text(snapshot.error.toString());
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  Widget buildList(AsyncSnapshot<ItemModel> snapshot) {
    return GridView.builder(
        itemCount: snapshot.data.results.length,
        gridDelegate:
        new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),
        itemBuilder: (BuildContext context, int index) {
          return GridTile(
            child: InkResponse(
              enableFeedback: true,
              child: Image.network(
                'https://image.tmdb.org/t/p/w185${snapshot.data
                    .results[index].poster_path}',
                fit: BoxFit.cover,
              ),
              onTap: () => openDetailPage(snapshot.data, index),
            ),
          );
        });
  }

  openDetailPage(ItemModel data, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) {
        return MovieDetail(
          title: data.results[index].title,
          posterUrl: data.results[index].backdrop_path,
          description: data.results[index].overview,
          releaseDate: data.results[index].release_date,
          voteAverage: data.results[index].vote_average.toString(),
          movieId: data.results[index].id,
        );
      }),
    );
  }
}
```

`openDetailPage()` 메소드에서 다음 화면으로 넘겨주는 작업을 진행합니다. 몇몇 필요한 데이터들을 Detail Screen의 생성자를 통해 넘겨줍니다.



##### Detail Screen 설명 보여주기

네트워크 콜을 통한 API 통신으로 응답받은 반응을 클래스에 담아 화면에 출력하는 과정이다.

```json
{
  "id": 299536,
  "results": [
    {
      "id": "5a200baa925141033608f5f0",
      "iso_639_1": "en",
      "iso_3166_1": "US",
      "key": "6ZfuNTqbHE8",
      "name": "Official Trailer",
      "site": "YouTube",
      "size": 1080,
      "type": "Trailer"
    },
    {
      "id": "5a200bcc925141032408d21b",
      "iso_639_1": "en",
      "iso_3166_1": "US",
      "key": "sAOzrChqmd0",
      "name": "Action...Avengers: Infinity War",
      "site": "YouTube",
      "size": 720,
      "type": "Clip"
    }
  ]
}
```

위와 같은 API 반응이 온다면, 아래와 같이 POJO(반응을 담을 객체)를 만들어준다.

`models - trailer_model.dart`

```dart
class TrailerModel {
  int _id;
  List<_Result> _results = [];

  TrailerModel.fromJson(Map<String, dynamic> parsedJson) {
    _id = parsedJson['id'];
    List<_Result> temp = [];
    for (int i = 0; i < parsedJson['results'].length; i++) {
      _Result result = _Result(parsedJson['results'][i]);
      temp.add(result);
    }
    _results = temp;
  }

  List<_Result> get results => _results;

  int get id => _id;
}

class _Result {
  String _id;
  String _iso_639_1;
  String _iso_3166_1;
  String _key;
  String _name;
  String _site;
  int _size;
  String _type;

  _Result(result) {
    _id = result['id'];
    _iso_639_1 = result['iso_639_1'];
    _iso_3166_1 = result['iso_3166_1'];
    _key = result['key'];
    _name = result['name'];
    _site = result['site'];
    _size = result['size'];
    _type = result['type'];
  }

  String get id => _id;

  String get iso_639_1 => _iso_639_1;

  String get iso_3166_1 => _iso_3166_1;

  String get key => _key;

  String get name => _name;

  String get site => _site;

  int get size => _size;

  String get type => _type;
}
```

`resources - movie_api_provider.dart` 파일에 API 호출 함수인 `fetchTrailer(movie_id)`를 추가한다.

```dart
import 'dart:async';
import 'package:http/http.dart' show Client;
import 'dart:convert';
import '../models/item_model.dart';
import '../models/trailer_model.dart';

class MovieApiProvider {
  Client client = Client();
  final _apiKey = '802b2c4b88ea1183e50e6b285a27696e';
  final _baseUrl = "http://api.themoviedb.org/3/movie";

  Future<ItemModel> fetchMovieList() async {
    final response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
    if (response.statusCode == 200) {
      // If the call to the server was successful, parse the JSON
      return ItemModel.fromJson(json.decode(response.body));
    } else {
      // If that call was not successful, throw an error.
      throw Exception('Failed to load post');
    }
  }

  Future<TrailerModel> fetchTrailer(int movieId) async {
    final response =
        await client.get("$_baseUrl/$movieId/videos?api_key=$_apiKey");

    if (response.statusCode == 200) {
      return TrailerModel.fromJson(json.decode(response.body));
    } else {
      throw Exception('Failed to load trailers');
    }
  }
}
```

새로운 네트워크 콜을 추가했으면 `repository.dart`도 수정해줘야 한다.

`fetchTrailers(int movieId)`를 추가해주자.

```dart
import 'dart:async';
import 'movie_api_provider.dart';
import '../models/item_model.dart';
import '../models/trailer_model.dart';

class Repository {
  final moviesApiProvider = MovieApiProvider();

  Future<ItemModel> fetchAllMovies() => moviesApiProvider.fetchMovieList();

  Future<TrailerModel> fetchTrailers(int movieId) => moviesApiProvider.fetchTrailer(movieId);
}
```

아래 두 파일을 생성한다.

`blocs - movie_detail_bloc_provider.dart`

```dart
import 'package:flutter/material.dart';
import 'movie_detail_bloc.dart';
export 'movie_detail_bloc.dart';

class MovieDetailBlocProvider extends InheritedWidget {
  final MovieDetailBloc bloc;

  MovieDetailBlocProvider({Key key, Widget child})
      : bloc = MovieDetailBloc(),
        super(key: key, child: child);

  @override
  bool updateShouldNotify(_) {
    return true;
  }

  static MovieDetailBloc of(BuildContext context) {
    return (context.inheritFromWidgetOfExactType(MovieDetailBlocProvider)
            as MovieDetailBlocProvider)
        .bloc;
  }
}
```

해당 클래스는 `InheritedWidget`을 상속받고, `of(context)`를 통한 bloc 접근을 제공한다. 파라미터로 들어오는 `context`는 InheritedWidget에 감싸져 있는 스크린에 속해있다. 이 예제에서는 `movie detail screen` 이다.

`blocs - movie_detail_bloc.dart`

```dart
import 'dart:async';

import 'package:rxdart/rxdart.dart';
import '../models/trailer_model.dart';
import '../resources/repository.dart';

class MovieDetailBloc {
  final _repository = Repository();
  final _movieId = PublishSubject<int>();
  final _trailers = BehaviorSubject<Future<TrailerModel>>();

  Function(int) get fetchTrailersById => _movieId.sink.add;
  Observable<Future<TrailerModel>> get movieTrailers => _trailers.stream;

  MovieDetailBloc() {
    _movieId.stream.transform(_itemTransformer()).pipe(_trailers);
  }

  dispose() async {
    _movieId.close();
    await _trailers.drain();
    _trailers.close();
  }

  _itemTransformer() {
    return ScanStreamTransformer(
      (Future<TrailerModel> trailer, int id, int index) {
        print(index);
        trailer = _repository.fetchTrailers(id);
        return trailer;
      },
    );
  }
}
```

trailerAPI에 movieId를 전달해주면 서버로부터 트레일러 목록을 받아오는 코드이다. 이것을 구현하기 위해서는 `RxDart`의 `Transformers`를 알아야 한다.

##### Transformers

 `transformers`는 두개 이상의 주체를 연결하고 최종 결과를 얻는데 도움이됩니다. 데이터에 대해 일부 작업한 후 다른 주체로 데이터를 전달(파이프)하려는 경우입니다.

여기서는 `_movieId`를  `ScanStreamTransformer` 를 통해서 트레일러API 네트워크 콜에게 넘겨주고, 받아온 결과를 `_trailers`  로 파이프 해줍니다.

아래는 일련의 절차를 설명한 그림입니다.

![Image for post](https://miro.medium.com/max/953/1*8EKpbLKC61gkS8jstJ_9kQ.png)

마지막으로 MovieDetail screen에 접근가능한 `movieDetailBloc` 을 만들어야 합니다. 그러기 위해서 아래와 같이 `openDetailPage()` 코드를 수정합니다.

`ui - movie_list.dart`

```dart
import 'package:flutter/material.dart';
import '../models/item_model.dart';
import '../blocs/movies_bloc.dart';
import 'movie_detail.dart';
import '../blocs/movie_detail_bloc_provider.dart';

class MovieList extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    return MovieListState();
  }
}

class MovieListState extends State<MovieList> {
  @override
  void initState() {
    super.initState();
    bloc.fetchAllMovies();
  }

  @override
  void dispose() {
    bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Popular Movies'),
      ),
      body: StreamBuilder(
        stream: bloc.allMovies,
        builder: (context, AsyncSnapshot<ItemModel> snapshot) {
          if (snapshot.hasData) {
            return buildList(snapshot);
          } else if (snapshot.hasError) {
            return Text(snapshot.error.toString());
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  Widget buildList(AsyncSnapshot<ItemModel> snapshot) {
    return GridView.builder(
        itemCount: snapshot.data.results.length,
        gridDelegate:
        new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),
        itemBuilder: (BuildContext context, int index) {
          return GridTile(
            child: InkResponse(
              enableFeedback: true,
              child: Image.network(
                'https://image.tmdb.org/t/p/w185${snapshot.data
                    .results[index].poster_path}',
                fit: BoxFit.cover,
              ),
              onTap: () => openDetailPage(snapshot.data, index),
            ),
          );
        });
  }

  openDetailPage(ItemModel data, int index) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) {
        return MovieDetailBlocProvider(
          child: MovieDetail(
            title: data.results[index].title,
            posterUrl: data.results[index].backdrop_path,
            description: data.results[index].overview,
            releaseDate: data.results[index].release_date,
            voteAverage: data.results[index].vote_average.toString(),
            movieId: data.results[index].id,
          ),
        );
      }),
    );
  }
}
```

기존과 달라진 점은 `MaterialPageRoute` 에서 반환되는 것이 `MovieDetail` 에서 MovieDetail을 감싼 `MovieDetailBlocProvider` 이라는 점입니다. 이렇게하면 `MovieDetailBloc` 클래스를 detail screen 내부와 하부 위젯에서 모두 이용할 수 있게 됩니다.

수정된 사항을 반영하기 위해  `movie_detail.dart` 를 수정해줍니다.

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import '../blocs/movie_detail_bloc_provider.dart';
import '../models/trailer_model.dart';

class MovieDetail extends StatefulWidget {
  final posterUrl;
  final description;
  final releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetail({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  State<StatefulWidget> createState() {
    return MovieDetailState(
      title: title,
      posterUrl: posterUrl,
      description: description,
      releaseDate: releaseDate,
      voteAverage: voteAverage,
      movieId: movieId,
    );
  }
}

class MovieDetailState extends State<MovieDetail> {
  final posterUrl;
  final description;
  final releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetailBloc bloc;

  MovieDetailState({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  void didChangeDependencies() {
    bloc = MovieDetailBlocProvider.of(context);
    bloc.fetchTrailersById(movieId);
    super.didChangeDependencies();
  }

  @override
  void dispose() {
    bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        top: false,
        bottom: false,
        child: NestedScrollView(
          headerSliverBuilder: (BuildContext context,
              bool innerBoxIsScrolled) {
            return <Widget>[
              SliverAppBar(
                expandedHeight: 200.0,
                floating: false,
                pinned: true,
                elevation: 0.0,
                flexibleSpace: FlexibleSpaceBar(
                    background: Image.network(
                      "https://image.tmdb.org/t/p/w500$posterUrl",
                      fit: BoxFit.cover,
                    )),
              ),
            ];
          },
          body: Padding(
            padding: const EdgeInsets.all(10.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                Container(margin: EdgeInsets.only(top: 5.0)),
                Text(
                  title,
                  style: TextStyle(
                    fontSize: 25.0,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Container(margin: EdgeInsets.only(top: 8.0,
                    bottom: 8.0)),
                Row(
                  children: <Widget>[
                    Icon(
                      Icons.favorite,
                      color: Colors.red,
                    ),
                    Container(
                      margin: EdgeInsets.only(left: 1.0,
                          right: 1.0),
                    ),
                    Text(
                      voteAverage,
                      style: TextStyle(
                        fontSize: 18.0,
                      ),
                    ),
                    Container(
                      margin: EdgeInsets.only(left: 10.0,
                          right: 10.0),
                    ),
                    Text(
                      releaseDate,
                      style: TextStyle(
                        fontSize: 18.0,
                      ),
                    ),
                  ],
                ),
                Container(margin: EdgeInsets.only(top: 8.0,
                    bottom: 8.0)),
                Text(description),
                Container(margin: EdgeInsets.only(top: 8.0,
                    bottom: 8.0)),
                Text(
                  "Trailer",
                  style: TextStyle(
                    fontSize: 25.0,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Container(margin: EdgeInsets.only(top: 8.0,
                    bottom: 8.0)),
                StreamBuilder(
                  stream: bloc.movieTrailers,
                  builder:
                      (context, AsyncSnapshot<Future<TrailerModel>> snapshot) {
                    if (snapshot.hasData) {
                      return FutureBuilder(
                        future: snapshot.data,
                        builder: (context,
                            AsyncSnapshot<TrailerModel> itemSnapShot) {
                          if (itemSnapShot.hasData) {
                            if (itemSnapShot.data.results.length > 0)
                              return trailerLayout(itemSnapShot.data);
                            else
                              return noTrailer(itemSnapShot.data);
                          } else {
                            return Center(child: CircularProgressIndicator());
                          }
                        },
                      );
                    } else {
                      return Center(child: CircularProgressIndicator());
                    }
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget noTrailer(TrailerModel data) {
    return Center(
      child: Container(
        child: Text("No trailer available"),
      ),
    );
  }

  Widget trailerLayout(TrailerModel data) {
    if (data.results.length > 1) {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
          trailerItem(data, 1),
        ],
      );
    } else {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
        ],
      );
    }
  }

  trailerItem(TrailerModel data, int index) {
    return Expanded(
      child: Column(
        children: <Widget>[
          Container(
            margin: EdgeInsets.all(5.0),
            height: 100.0,
            color: Colors.grey,
            child: Center(child: Icon(Icons.play_circle_filled)),
          ),
          Text(
            data.results[index].name,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
}
```

몇가지 알아둬야 할 점이 있습니다. 우리는 `didChangeDependencies()` 안에서 `MovieDetailBloc` 을 초기화했습니다. 또한  `StreamBuilder’s` snapshot data에는 `FutureBuilder` 에서만 사용할 수 있는 `Future<TrailerModel>` 가 포함되어있습니다.

***너무 많은 새로운 것을 소개했기 때문에 이 내용은 깊이 설명하지 않습니다.***



## PART 3

기존에 BLOC패턴으로 작성했던 코드에 의존성 주입을 추가하겠습니다.

##### Content

1. Dependency Injection이란 무엇인가?
2. `inject.dart` 패키지를 서브모듈로 프로젝트에 추가하기
3. annotaions (@provide, @module, etc) 이해하기
4. modules 과 Injector 클래스 구현하기
5. 컴파일 시점에서 dependencies 해결하기
6. 앱 실행



#### 1. Dependency Injection 이란 무엇인가?

> DI에 대해 잘 설명되어 있는 [article](https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/)

실세계의 예를 들자면, 휴대폰 조립이 있다. 휴대폰에는 회로, 안테나, LCD, 마이크, 스피커, 배터리 등 많은 부품이 필요하다. 하지만 이러한 부품들은 한 공장에서 만들어지지 않고, 조립공장으로 모여 하나의 휴대폰으로 조립하게 된다. *이것이 바로 Dependency Injection이다.*

조립 공장은 부품들이 어떻게 만들어지는지 과정을 알 필요가 없다. 그저 조립하는 것에만 신경을 쓰면 된다. 이것이 DI의 장점이자 간단한 설명이다. **즉, DI는 외부에서 필요한 것들을 만들어서 보내주는 것이다. 사용하는 곳에서는 사용만 하도록, 사용할 것을 만드는 곳은 따로 있는 것이다.**



#### 2. inject.dart 패키지를 서브모듈로 프로젝트에 추가하기

##### 사전준비

앞선 코드를 따라했다면 아래와 같은 패키지 구성으로 되어있을 것이다.

![Image for post](https://miro.medium.com/max/460/1*0IBkKKsybpKWVXwFi3TnKw.png)

##### 문제 제기

우리가 현재 짠 코드에서는 문제점이 있다.  `movie_api_provider.dart` 파일을 열어서 2번째 줄을 보면 새로운`Client() 객체` 를 `MovieApiProvider` 클래스 안에서 생성하는 것을 볼 수 있다. DI 에서 설명했듯이 이부분은 잘못된 부분이다.  `MovieApiProvider` 는 `Client() 객체` 생성에 관여해서는 안된다. 다른 누군가로부터 제공받아야한다.

![Image for post](https://miro.medium.com/max/1115/1*BuvTcz-0cUveaktlTDtw6w.png)

이것은 한 예시일 뿐이고, `repository.dart` 과 `movies_bloc.dart` 와 같은 다른 곳에서도 이러한 케이스가 있다는 것을 확인할 수 있다.

또한 DI 패턴의 다른 매력은 bloc이나 다른 어떠한 타입의 객체를 제공해주기 위해서 사용했던 `BlocProviders (InheritedWidgets)` 을 더이상 사용할 필요가 없다는 것이다.  `InheritedWidgets` 은 빌드 시에 종속성 문제를 해결하지 못하지만 종속성 연결이 올바르지 못하면 런타임 에러를 띄워준다.

##### 해법: inject.dart

위에서 말한 문제를 해결하기 위해, 우리는 `inject.dart` 를 사용한다. 이것은 구글에서 만든 오픈소스 컴파일 의존성 주입 패키지이다. 이 패키지는 우리가 필요로 하는 객체와 주입들을 생성하는 데에 도움을 준다. 이 패키지의 최고는, '빌드 시 모든 종속성 문제를 해결해준다' 이다. 따라서 공급자와 종속성 연결과 관련된 런타임 예외는 없다. 즉, 앱을 실행하기 전에 모든 객체가 생성되었는지 종속성이 해결되었는지 확인한다.

이 프레임워크는 'leak' 하지 않으며, 부작용이 없고, downstream dependencies 가 요구되지 않는다. 또한 dart의 코어만 사용하기에 특정 플랫폼이 아니다. (Flutter or AngularDart)

##### :star::star:  inject.dart 추가하기 :star: :star: 

이 패지키를 추가하는 방법은 기존의 방법과는 다르다. `MyMovies` 디렉토리 안에 `injection`  이름의 폴더를 만든다.(다른 이름을 사용해도 된다.) 해당 폴더 경로의 터미널을 하나 켠 후, 아래의 명령어를 입력하면 된다.

`git submodule add https://github.com/google/inject.dart`

설치되면 아래와 같이 생성되는 것을 확인할 수 있다.

![Image for post](https://miro.medium.com/max/605/1*6vc6BWjlSVTwJecJcmgneA.png)

현재 에러나는 것은 앞으로 고칠 것이기에 무시한다.



`pubspec.yaml` inject 종속성을 추가해준다.

```
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^0.1.2
  rxdart: ^0.18.0
  http: ^0.12.0+1
  inject:
    path: ./injection/inject.dart/package/inject

dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner: ^1.0.0
  inject_generator:
    path: ./injection/inject.dart/package/inject_generator
```

`build_runner` 패키지는 Dart 코드를 사용하여 파일을 생성하는 구체적인 방법을 제공합니다. 프로젝트를 컴파일링 마지막에 `build_runner` 를 사용합니다.



`src` 밑에 `di` 라고 하나의 패키지를 새로 만들어 준다. 만들어 준 후, `bloc_injector.dart` 와 `bloc_module.dart` 두 파일을 `di` 패키지 안에 생성해준다.

#### 3. modules 와 Injector 클래스 작성

`bloc_module.dart` 를 먼저 작업하자. 우선 아래의 코드를 복붙한다.

```dart
import 'package:inject/inject.dart';
import '../blocs/movies_bloc.dart';
import '../blocs/movie_detail_bloc.dart';
import '../blocs/bloc_base.dart';
import '../resources/repository.dart';
import '../resources/movie_api_provider.dart';
import 'package:http/http.dart' show Client;

@module
class BlocModule{

  @provide
  @singleton
  Client client() => Client();

  @provide
  @singleton
  MovieApiProvider movieApiProvider(Client client) => MovieApiProvider(client);

  @provide
  @singleton
  Repository repository(MovieApiProvider movieApiProvider) => Repository(movieApiProvider);

  @provide
  BlocBase movieBloc(Repository repository) => MoviesBloc(repository);

  @provide
  BlocBase movieDetailBloc(Repository repository) => MovieDetailBloc(repository);
}
```

Dagger를 기존에 써본 적이 있다면 이것이 무엇을 의미하는지 이해하기 쉬울 것이다.

하지만 걱정 말아라. 여기서 사용된 어노테이션에 대해 설명해 줄 것이다. 또한 에러가 나타나는 곳도 곧 수정할 것이다.

> ##### annotations 이해하기
> 
> `@module` :  이 annotation(주석)은 `inject.dart` 가 생성하는 의존성 그래프에 기여하기 위해  `BlocModule` 클래스를 사용할 수 있게 해준다. 다른 클래스에 필요한 모든 종속성을 가지고 있다.
> 
> `@provide` : 이 어노테이션을 가지고 있는 모든 method들은 종속성 주입에 사용할 수 있다.
> 
> `@singleton` : 객체의 단일 인스턴스를 만들고 제공한다. (이 객체는 유일하다고 볼 수 있다.)



`bloc_injector.dart` 를 열어 아래 코드를 추가한다.

```dart
import 'package:inject/inject.dart';
import 'bloc_injector.inject.dart' as g;
import '../app.dart';
import 'bloc_module.dart';

@Injector(const [BlocModule])
abstract class BlocInjector{
  @provide
  App get app;

  static final create = g.BlocInjector$Injector.create;
}
```

에러가 보이지만, `bloc_injector.inject.dart` 파일이 빌드 시에 생성되면서 에러가 해결된다. 파일이 생성되면 `create()` 메소드도 보겠습니다. 여기서 알아야 할 것은 `App get app;` 이다. 이것은 우리 프로젝트의 루트 위젯이고, 종속성 주입의 목적지로 제공하기 위해 선언한다.

> `@Injector` : 우리가 이전에 종속 객체를 조립하는 공장에 대해 말했던 것을 기억해라. 그것이 이 annotation이 하는 일이다. 이것은 모든 것을 접착하고 주입할 수 있는 모든 객체를 사용할 수 있게 할 것이다. 이렇게 하면 Injector가 해결 및 제공해야 하는 모든 객체를 알 수 있기 때문에 모든 종속 모듈을 인자로 사용한다.



`main.dart` 파일을 열어 아래 코드로 고친다.

```dart
import 'package:flutter/material.dart';
import 'src/di/bloc_injector.dart';
import 'src/di/bloc_module.dart';

void main() async {
  var container = await BlocInjector.create(BlocModule());
  runApp(container.app);
}
```

`container` 객체는 `bloc_injector.inject.dart` 파일을 생성할 때 설명하겠다.



`app.dart` 파일을 열어 아래 코드로 고친다.

```dart
import 'package:flutter/material.dart';
import 'ui/movie_list.dart';
import 'package:inject/inject.dart';
import 'ui/movie_detail.dart';
import 'models/item_model.dart';
import 'blocs/movies_bloc.dart';
import 'blocs/movie_detail_bloc.dart';

class App extends StatelessWidget {
  final MoviesBloc moviesBloc;
  final MovieDetailBloc movieDetailBloc;

  @provide
  App(this.moviesBloc, this.movieDetailBloc): super();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData.dark(),
      initialRoute: '/',
      onGenerateRoute: (settings){

        if(settings.name == 'movieDetail'){
          final Result result = settings.arguments;
          return MaterialPageRoute(
            builder: (context){
              return MovieDetail(
                movieDetailBloc,
                result.title,
                result.backdrop_path,
                result.overview,
                result.release_date,
                result.vote_average.toString(),
                result.id,
              );
            }
          );
        }
      },
      routes: {
        '/': (context) => MovieList(moviesBloc),
      },
    );
  }
}
```

에러는 곧 고칠 것이니 무시하자. 위 코드에서 `MoviesBloc` 과 `MoviesDetailBloc` 객체는 모두 생성자 주입을 통해 제공되며 나중에 해당 클래스 (MovieList, MovieDetail screen ...)로 전달된다. 이제 더이상 여기서는 객체 생성이 일어나지 않는다! :open_mouth: :clap: 



`bloc - bloc_base.dart` 를 새로 만들고 아래 코드를 붙여 넣는다.

```dart
abstract class BlocBase{
  void dispose();
}
```



`movie_detail_bloc.dart` 파일을 열어 아래 코드를 붙여넣는다.

```dart
import 'dart:async';

import 'package:rxdart/rxdart.dart';
import '../models/trailer_model.dart';
import '../resources/repository.dart';
import 'bloc_base.dart';
import 'package:inject/inject.dart';

class MovieDetailBloc extends BlocBase {

  final Repository _repository;
  PublishSubject<int> _movieId;
  BehaviorSubject<Future<TrailerModel>> _trailers;

  @provide
  MovieDetailBloc(this._repository);

  Function(int) get fetchTrailersById => _movieId.sink.add;
  Observable<Future<TrailerModel>> get movieTrailers => _trailers.stream;

  init(){
    _movieId = PublishSubject<int>();
    _trailers = BehaviorSubject<Future<TrailerModel>>();
    _movieId.stream.transform(_itemTransformer()).pipe(_trailers);
  }

  @override
  dispose() async {
    _movieId.close();
    await _trailers.drain();
    _trailers.close();
  }

  _itemTransformer() {
    return ScanStreamTransformer(
      (Future<TrailerModel> trailer, int id, int index) {
        trailer = _repository.fetchTrailers(id);
        return trailer;
      },
    );
  }
}
```

달라진 점은 `Repository` 객체를 `MovieDetailBloc` 내에서 생성하지 않는다는 것이다. 대신에 생성자 인수로 객체를 주입했다. :open_mouth: :open_mouth:



`movies_bloc.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import '../resources/repository.dart';
import 'package:rxdart/rxdart.dart';
import '../models/item_model.dart';
import 'package:inject/inject.dart';
import 'bloc_base.dart';

class MoviesBloc extends BlocBase {

  final Repository _repository;
  PublishSubject<ItemModel> _moviesFetcher;

  @provide
  MoviesBloc(this._repository);

  init(){
    _moviesFetcher = PublishSubject<ItemModel>();
  }

  Observable<ItemModel> get allMovies => _moviesFetcher.stream;

  fetchAllMovies() async {
    ItemModel itemModel = await _repository.fetchAllMovies();
    _moviesFetcher.sink.add(itemModel);
  }

  @override
  dispose() {
    _moviesFetcher.close();
  }
}
```

여기도 마찬가지로 `Repository` 객체를 `MovieBloc` 클래스 내에서 생성하지 않는다. 밖에서 제공된다. :open_mouth:



`movie_api_provider.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' show Client, Response;
import '../models/item_model.dart';
import '../models/trailer_model.dart';
import 'package:inject/inject.dart';

class MovieApiProvider {
  final Client client;
  final _apiKey = 'api-key';
  final _baseUrl = "http://api.themoviedb.org/3/movie";

  @provide
  MovieApiProvider(this.client);

  Future<ItemModel> fetchMovieList() async {
    Response response;
    if(_apiKey != 'api-key') {
       response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
    }else{
      throw Exception('Please add your API key');
    }
    if (response.statusCode == 200) {
      // If the call to the server was successful, parse the JSON
      return ItemModel.fromJson(json.decode(response.body));
    } else {
      // If that call was not successful, throw an error.
      throw Exception('Failed to load post');
    }
  }

  Future<TrailerModel> fetchTrailer(int movieId) async {
    final response =
        await client.get("$_baseUrl/$movieId/videos?api_key=$_apiKey");

    if (response.statusCode == 200) {
      return TrailerModel.fromJson(json.decode(response.body));
    } else {
      throw Exception('Failed to load trailers');
    }
  }
}
```

`Client` 객체를 `MovieApiProvider` 클래스 내에서 생성하지 않았다. `@provide` 는 DI 프레임워크가 필요한 모든 종속성을 찾아 그에 맞는 코드를 생성하도록 돕는데 사용된다.



`repository.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'dart:async';
import 'movie_api_provider.dart';
import '../models/item_model.dart';
import '../models/trailer_model.dart';
import 'package:inject/inject.dart';

class Repository {

  final MovieApiProvider moviesApiProvider;

  @provide
  Repository(this.moviesApiProvider);

  Future<ItemModel> fetchAllMovies() => moviesApiProvider.fetchMovieList();

  Future<TrailerModel> fetchTrailers(int movieId) => moviesApiProvider.fetchTrailer(movieId);
}
```

가장 좋은 점은, `BlocModule` 을 생성할 당시 `MovieApiProvider` 를 `singleton` 으로 어노테이션 해놨기때문에 `movieApiProvider` 는 딱 한번만 생성된다는 것이다.



`movie_detail.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import '../blocs/movie_detail_bloc.dart';
import '../models/trailer_model.dart';

class MovieDetail extends StatefulWidget {
  final MovieDetailBloc bloc;
  final String posterUrl;
  final String description;
  final String releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetail(
    this.bloc,
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  );

  @override
  State<StatefulWidget> createState() {
    return MovieDetailState(
      title: title,
      posterUrl: posterUrl,
      description: description,
      releaseDate: releaseDate,
      voteAverage: voteAverage,
      movieId: movieId,
    );
  }
}

class MovieDetailState extends State<MovieDetail> {
  final String posterUrl;
  final String description;
  final String releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetailState({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  void initState() {
    super.initState();
    widget.bloc.init();
    widget.bloc.fetchTrailersById(movieId);
  }

  @override
  void dispose() {
    widget.bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        top: false,
        bottom: false,
        child: NestedScrollView(
            headerSliverBuilder:
                (BuildContext context, bool innerBoxIsScrolled) {
              return <Widget>[
                SliverAppBar(
                  expandedHeight: 200.0,
                  floating: false,
                  pinned: true,
                  elevation: 0.0,
                  flexibleSpace: FlexibleSpaceBar(
                      background: Image.network(
                    "https://image.tmdb.org/t/p/w500$posterUrl",
                    fit: BoxFit.cover,
                  )),
                ),
              ];
            },
            body: ListView(
              children: <Widget>[
                Padding(
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: <Widget>[
                      Container(margin: EdgeInsets.only(top: 5.0)),
                      Text(
                        title,
                        style: TextStyle(
                          fontSize: 25.0,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Row(
                        children: <Widget>[
                          Icon(
                            Icons.favorite,
                            color: Colors.red,
                          ),
                          Container(
                            margin: EdgeInsets.only(left: 1.0, right: 1.0),
                          ),
                          Text(
                            voteAverage,
                            style: TextStyle(
                              fontSize: 18.0,
                            ),
                          ),
                          Container(
                            margin: EdgeInsets.only(left: 10.0, right: 10.0),
                          ),
                          Text(
                            releaseDate,
                            style: TextStyle(
                              fontSize: 18.0,
                            ),
                          ),
                        ],
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Text(description),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Text(
                        "Trailer",
                        style: TextStyle(
                          fontSize: 25.0,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      StreamBuilder(
                        stream: widget.bloc.movieTrailers,
                        builder: (context,
                            AsyncSnapshot<Future<TrailerModel>> snapshot) {
                          if (snapshot.hasData) {
                            return FutureBuilder(
                              future: snapshot.data,
                              builder: (context,
                                  AsyncSnapshot<TrailerModel> itemSnapShot) {
                                if (itemSnapShot.hasData) {
                                  if (itemSnapShot.data.results.length > 0)
                                    return trailerLayout(itemSnapShot.data);
                                  else
                                    return noTrailer(itemSnapShot.data);
                                } else {
                                  return Center(
                                      child: CircularProgressIndicator());
                                }
                              },
                            );
                          } else {
                            return Center(child: CircularProgressIndicator());
                          }
                        },
                      ),
                    ],
                  ),
                ),
              ],
            )),
      ),
    );
  }

  Widget noTrailer(TrailerModel data) {
    return Center(
      child: Container(
        child: Text("No trailer available"),
      ),
    );
  }

  Widget trailerLayout(TrailerModel data) {
    if (data.results.length > 1) {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
          trailerItem(data, 1),
        ],
      );
    } else {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
        ],
      );
    }
  }

  trailerItem(TrailerModel data, int index) {
    return Expanded(
      child: Column(
        children: <Widget>[
          Container(
            margin: EdgeInsets.all(5.0),
            height: 100.0,
            color: Colors.grey,
            child: Center(child: Icon(Icons.play_circle_filled)),
          ),
          Text(
            data.results[index].name,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
}
```

기존에 있던 `didChangeDependencies()` 가 `initState()` 로 바꼈다. 해당 메소드 안에서 `bloc` 객체를 사용하기 위해 `MovieDetailBlocProvider` (`InhertiedWidget`) 클래스를 이용했다.

DI를 적용한 후엔, `MovieDetailBloc` 은 생성자 인자로 주입되었다. 그리고 `bloc` 객체를 이용하는 방법이 약간 바뀌었다. `bloc` 이 아니라  `widget.bloc` 을 이용하여야 한다.



`movie_list.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'package:flutter/material.dart';
import '../models/item_model.dart';
import '../blocs/movies_bloc.dart';

class MovieList extends StatefulWidget {
  final MoviesBloc _bloc;

  MovieList(this._bloc);

  @override
  State<StatefulWidget> createState() {
    return MovieListState();
  }
}

class MovieListState extends State<MovieList> {
  @override
  void initState() {
    super.initState();
    widget._bloc.init();
    widget._bloc.fetchAllMovies();
  }

  @override
  void dispose() {
    widget._bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Popular Movies'),
      ),
      body: StreamBuilder(
        stream: widget._bloc.allMovies,
        builder: (context, AsyncSnapshot<ItemModel> snapshot) {
          if (snapshot.hasData) {
            return buildList(snapshot);
          } else if (snapshot.hasError) {
            return Text(snapshot.error.toString());
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  Widget buildList(AsyncSnapshot<ItemModel> snapshot) {
    return GridView.builder(
        itemCount: snapshot.data.results.length,
        gridDelegate:
        new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),
        itemBuilder: (BuildContext context, int index) {
          return GridTile(
            child: InkResponse(
              enableFeedback: true,
              child: Image.network(
                'https://image.tmdb.org/t/p/w185${snapshot.data
                    .results[index].poster_path}',
                fit: BoxFit.cover,
              ),
              onTap: () => openDetailPage(snapshot.data, index),
            ),
          );
        });
  }

  openDetailPage(ItemModel data, int index) {
    Navigator.pushNamed(
      context,
      'movieDetail', arguments: data.results[index]);
  }
}
```

여기도 마찬가지로 `MoviesBloc` 객체를 생성자를 통해 주입했다.



`item_model.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
class ItemModel {
  int _page;
  int _total_results;
  int _total_pages;
  List<Result> _results = [];

  ItemModel.fromJson(Map<String, dynamic> parsedJson) {
    print(parsedJson['results'].length);
    _page = parsedJson['page'];
    _total_results = parsedJson['total_results'];
    _total_pages = parsedJson['total_pages'];
    List<Result> temp = [];
    for (int i = 0; i < parsedJson['results'].length; i++) {
      Result result = Result(parsedJson['results'][i]);
      temp.add(result);
    }
    _results = temp;
  }

  List<Result> get results => _results;

  int get total_pages => _total_pages;

  int get total_results => _total_results;

  int get page => _page;
}

class Result {
  int _vote_count;
  int _id;
  bool _video;
  String _vote_average;
  String _title;
  double _popularity;
  String _poster_path;
  String _original_language;
  String _original_title;
  List<int> _genre_ids = [];
  String _backdrop_path;
  bool _adult;
  String _overview;
  String _release_date;

  Result(result) {
    _vote_count = result['vote_count'];
    _id = result['id'];
    _video = result['video'];
    _vote_average = result['vote_average'].toString();
    _title = result['title'];
    _popularity = result['popularity'];
    _poster_path = result['poster_path'];
    _original_language = result['original_language'];
    _original_title = result['original_title'];
    for (int i = 0; i < result['genre_ids'].length; i++) {
      _genre_ids.add(result['genre_ids'][i]);
    }
    _backdrop_path = result['backdrop_path'];
    _adult = result['adult'];
    _overview = result['overview'];
    _release_date = result['release_date'];
  }

  String get release_date => _release_date;

  String get overview => _overview;

  bool get adult => _adult;

  String get backdrop_path => _backdrop_path;

  List<int> get genre_ids => _genre_ids;

  String get original_title => _original_title;

  String get original_language => _original_language;

  String get poster_path => _poster_path;

  double get popularity => _popularity;

  String get title => _title;

  String get vote_average => _vote_average;

  bool get video => _video;

  int get id => _id;

  int get vote_count => _vote_count;
}
```

사소한 수정을 했다. `Result` 타입의 경로를 인자로 전달해주기 위해 `Result` 클래스를 `public` 으로 변경했다.



코드 수정은 여기까지다. 이제부터는 프로젝트를 어떻게 컴파일 할 것인가에 대해 집중할 것이다. 매우 중요한 과정이니 집중하길 바란다.

 프로젝트 디렉토리안에 `inject_generator_build.yaml` 이라는 파일을 만든다. 정확한 위치는 아래 그림을 참조하라.

![Image for post](https://miro.medium.com/max/409/1*JZkjc7LlAR3Q1xfxaYgINQ.png)

그리고 아래 코드를 복사해서 해당 파일에 붙여넣어라.

```
# Read about `build.yaml` at https://pub.dartlang.org/packages/build_config
builders:
  inject_generator:
    target: ":inject_generator"
    import: "package:inject_generator/inject_generator.dart"
    builder_factories:
      - "summarizeBuilder"
      - "generateBuilder"
    build_extensions:
      ".dart":
        - ".inject.summary"
        - ".inject.dart"
    auto_apply: dependents
    build_to: source
```

기본적으로 생성된 모든 파일은 `cache` 폴더로 이동하며, 플러터에서는 해당 폴더의 파일에 접근할 수 없기 때문에 이 파일을 만들었습니다. (해당 문제는 수정중에 있다고 합니다.) 따라서 `build_to: cache` 를 `build_to: source` 로 바꿔줍니다.

#### 4. 컴파일 시점에서 종속성 해결하기

> 오류시 참고. https://stackoverflow.com/questions/58023664/flutter-pub-run-build-runner-build-failed
>
> 

프로젝트 폴더를 지점으로 터미널을 열어 아래 코드를 입력한다.

```
flutter packages pub run build_runner build
```

#### 5. 앱 실행

`build_runner` 가 모든 종속성 문제를 해결하면 아래와 같은 결과를 볼 수 있을 것이다.

![Image for post](https://miro.medium.com/max/493/1*PbalVYYBRv1vryMrE7pDeA.png)

여기까지 왔다면, 종속성 그래프 생성에 성공한 것이다. 축하한다!! :clap::clap::clap::clap:

##### 정리

코드 생성이 성공하면, 아래와 같이 프로젝트에 많은 파일이 추가된 것이 보일 것이다.

![Image for post](https://miro.medium.com/max/548/1*pLnpIK-KPY223a88VKcvlw.png)

당황하지 마라! 이것은 정상적이다. `bloc_injector.inject.dart` 파일만 제외하면 모든 `*.inject.dart` 와 `*.summary`  파일을 지울 수 있다. 심지어 `movie_detail_bloc_provider.dart` 도 지울 수 있다. 이러한 삭제과정을 자동으로 진행할 수 있다. `lib` 과 `scr` 의 하부 디렉토리로 이동하여 아래 명령어를 입력하면 자동으로 삭제가 된다.

```
find . -size 0 -delete
```

##### 생성된 그래프 탐색

```dart
import 'bloc_injector.dart' as _i1;
import 'bloc_module.dart' as _i2;
import 'package:http/src/client.dart' as _i3;
import '../resources/movie_api_provider.dart' as _i4;
import '../resources/repository.dart' as _i5;
import 'dart:async' as _i6;
import '../app.dart' as _i7;
import '../blocs/movies_bloc.dart' as _i8;
import '../blocs/movie_detail_bloc.dart' as _i9;

class BlocInjector$Injector implements _i1.BlocInjector {
  BlocInjector$Injector._(this._blocModule);

  final _i2.BlocModule _blocModule;

  _i3.Client _singletonClient;

  _i4.MovieApiProvider _singletonMovieApiProvider;

  _i5.Repository _singletonRepository;

  static _i6.Future<_i1.BlocInjector> create(_i2.BlocModule blocModule) async {
    final injector = BlocInjector$Injector._(blocModule);

    return injector;
  }

  _i7.App _createApp() =>
      _i7.App(_createMoviesBloc(), _createMovieDetailBloc());
  _i8.MoviesBloc _createMoviesBloc() => _i8.MoviesBloc(_createRepository());
  _i5.Repository _createRepository() => _singletonRepository ??=
      _blocModule.repository(_createMovieApiProvider());
  _i4.MovieApiProvider _createMovieApiProvider() =>
      _singletonMovieApiProvider ??=
          _blocModule.movieApiProvider(_createClient());
  _i3.Client _createClient() => _singletonClient ??= _blocModule.client();
  _i9.MovieDetailBloc _createMovieDetailBloc() =>
      _i9.MovieDetailBloc(_createRepository());
  @override
  _i7.App get app => _createApp();
}
```

와우! 생성된 코드에서 `MoviesBloc` 이랑 `MovieDetailBloc` 객체가 `App` 위젯으로 생성자 인자로 넘어가는게 보이니? 너무 아름답지 :heart:!! 이 파일을 찬찬히 잘 보면, `BlocModule` 과 `bloc_injector.dart` 파일의 목적을 이해할 수 있을 거야.

##### git에 올리기

git에 올리기 전에 올리면 안되는 파일들이 있어. 그래서 `.gitignore` 파일에 아래 코드를 추가해줘.

```
*.inject.summary
```

그럼 끝!! 이만 안뇽 :hand: ~



## PART4

마지막 단원에서 다룰 내용은 **통합 및 단위 테스트** 이다. 이것은 기대치에 맞는 소프트웨어를 제공하고 예상치 못한 결과를 방지하는 데 도움이 된다.

##### Content

1. test 디렉토리 만들기
2. `Network Layer` 단에서의 유닛 테스트
3. `BLoC` 통합 테스트
4. 테스트 케이스 실행

##### 목표

소프트웨어 테스트는 모든 소프트웨어 개발 라이프사이클에서 가장 중요한 부분이다. 이를 통해 개발 단계에서 발생한 버그와 오류를 찾을 수 있다. 궁극적으로 이 방법론은 고객에게 양질의 제품을 배송하는데 도움이 될 것이다.

오늘은 이전에 만들었던 *MyMovies* 앱의 기능을 테스트한다.

##### 단위 및 통합 테스트

***단위 테스트***는 일부분의 코드가 프로그래머의 의도한 대로 작동하는지 확인하기 위함이다. 매우 좁은 범위이고, 쉽게 작성하고 테스트 할 수 있다. 단위 테스트의 일부분은 테스트 대상 코드 밖의 내용이 가짜(모의) 이거나 토막(일부분) 임을 의미한다. *단위 테스트는 외부 시스템에 의존해서는 안된다.*

***통합 테스트***는 시스템의 서로 다른 부분들이 함께 작동한다는 것을 입증하기 위함이다. 전체 애플리케이션을 포함할 수 있으며, 통합하기 위해 훨씬 더 많은 노력을 필요로 한다. 일반적으로 데이터베이스 인스턴스 및 하드웨어 같은 리소스를 할당해야 한다. 통합 테스트는 적어도 동일한 환경에서의 단위 테스트보다 시스템 작동 (특히 비 프로그래머)을 시연하는데에 더 설득력있다.

이 정도의 지식을 알고 있다면 코드의 어떤 부분이 단위 테스트이고, 어떻게 통합 테스트를 작성해야하는 지 이해하는데 도움이 될 것이다.

#### 1. 'test' 디렉토리 만들기

현재 프로젝트 구조는 아래와 같은 모양일 것이다.

![Image for post](https://miro.medium.com/max/409/1*JZkjc7LlAR3Q1xfxaYgINQ.png)

##### 의존성 정리(Refactoring)

테스트 파트로 넘어가기 전에 이전에 수행한 방식을 재구성하여 프로젝트에 inject.dart를 추가하자.

프로젝트의 `injection` 하위 모듈을 삭제한다. `pubspec.yaml` 파일을 열어 아래에 표시해둔 의존성을 삭제한다.

![Image for post](https://miro.medium.com/max/626/1*XfgLSu6oRYWJl-hM655ebA.png)

`pubspec.yaml` 에 아래와 같이 의존성을 추가한다.

```yaml
name: my_movies
description: A new Flutter application.

dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^0.1.2
  rxdart: ^0.18.0
  http: ^0.12.0+1
  inject:
    git:
      url: https://github.com/google/inject.dart.git
      path: package/inject

dependency_overrides:
  analyzer: ^0.36.3

dev_dependencies:
  flutter_test:
    sdk: flutter

  build_runner: ^1.6.1

  inject_generator:
    git:
      url: https://github.com/google/inject.dart.git
      path: package/inject_generator
  mockito: ^4.1.0

flutter:

  uses-material-design: true
```

코드를 보면, `inject.dart` 프레임워크 경로를 `url` 로 바꿨다. `inject.dart` 를 로컬 서브 모듈로 놔두는 대신에 컴파일 시에 추가된다.

또한 테스트를 위한 데모 데이터를 생성 도움을 주는 `mockito` 도 추가했다.

제 `flutter pub get` 을 실행하면 모든 것이 제대로 작동 할 것이다.

##### 테스트 모듈 만들기

프로젝트에 `test` 디렉토리를 만들자. 여기에 모든 테스트 케이스를 넣을 것이다.

![Image for post](https://miro.medium.com/max/354/1*alA_IFlX-OvZDyDdWMxpuQ.png)

`test` 폴더 안에 `unit_test` 와 `integration_test` 두 개의 서브폴더를 만든다. 이 디렉토리들은 각각의 테스트 케이스를 가지게 된다.

![Image for post](https://miro.medium.com/max/240/1*JM3LNiampeJ8MY4jJzehVA.png)

##### 테스트할 레이어

무슨 레이어을 테스트할지 얘기해보자. 아래 그림은 이를 명확하게 보여준다.

![Image for post](https://miro.medium.com/max/651/1*IwlTqjq3Z37o8sB5MMzgMg.png)

위에 다이어그램을 보면, 네트워크 레이어(`MovieApiProvider`)를 *단위 테스트* 하는 것을 볼 수 있다. JSON 파싱이 제대로 됐는지, 다른 HTTP 상태 코드가 제공될 때 코드가 어떻게 동작하는지 테스트한다.

그 다음 BLoC, Repository 및 Network Layer 모듈들이 논리적으로 통합되는지 확안히가 위해 통합 테스트를 진행합니다.



#### 2. Network Layer 단위 테스트

자, 이제 *Network Layer*인 `MovieApiProvider` 에서의 유닛 테스트 케이스를 작성해보자.

아래 보이는 코드는 현재 작성되어있는 `MovieApiProvider` 이다.

```dart
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' show Client, Response;
import '../models/item_model.dart';
import '../models/trailer_model.dart';
import 'package:inject/inject.dart';

class MovieApiProvider {
  final Client client;
  final _apiKey = 'api-key';
  final _baseUrl = "http://api.themoviedb.org/3/movie";

  @provide
  MovieApiProvider(this.client);

  Future<ItemModel> fetchMovieList() async {
    Response response;
    if(_apiKey != 'api-key') {
       response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
    }else{
      throw Exception('Please add your API key');
    }
    if (response.statusCode == 200) {
      // If the call to the server was successful, parse the JSON
      return ItemModel.fromJson(json.decode(response.body));
    } else {
      // If that call was not successful, throw an error.
      throw Exception('Failed to load post');
    }
  }

  Future<TrailerModel> fetchTrailer(int movieId) async {
    final response =
        await client.get("$_baseUrl/$movieId/videos?api_key=$_apiKey");

    if (response.statusCode == 200) {
      return TrailerModel.fromJson(json.decode(response.body));
    } else {
      throw Exception('Failed to load trailers');
    }
  }
}
```

위 코드를 보면, `fetchMovieList()` 와 `fetchTrailer()` 을 단위 테스팅한다는 것을 알 수 있다. 하지만 예외(`Exception`)를 발생시키고 있기에, 특정 상태(`state`)를 제공하도록 위의 코드를 아래와 같이 수정해야한다.

```dart
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' show Client, Response;
import '../models/item_model.dart';
import '../models/trailer_model.dart';
import 'package:inject/inject.dart';
import '../models/state.dart';

class MovieApiProvider {
  final Client client;
  final _apiKey = 'api-key';
  final _baseUrl = "http://api.themoviedb.org/3/movie";

  @provide
  MovieApiProvider(this.client);

  Future<State> fetchMovieList() async {
    Response response;
    if(_apiKey != 'api-key') {
       response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
    }else{
      return State<String>.error('Please add your API key');
    }
    if (response.statusCode == 200) {
      // If the call to the server was successful, parse the JSON
      return State<ItemModel>.success(ItemModel.fromJson(json.decode(response.body)));
    } else {
      // If that call was not successful, throw an error.
      return State<String>.error(response.statusCode.toString());
    }
  }

  Future<State> fetchTrailer(int movieId) async {
    final response =
        await client.get("$_baseUrl/$movieId/videos?api_key=$_apiKey");

    if (response.statusCode == 200) {
      return State<TrailerModel>.success(TrailerModel.fromJson(json.decode(response.body)));
    } else {
      return State<String>.error(response.statusCode.toString());
    }
  }
}
```

`예외` 를 바로 던지는 것이 아니라 특정한 `상태`(성공, 실패)를 제공한다.

이제 나머지 클래스들인 `repository.dart`, `movies_bloc.dart`, `movie_detail_bloc.dart` 도 수정해보자.



`repository.dart` 파일을 열어 아래와 같이 수정한다.

```dart
import 'dart:async';
import 'movie_api_provider.dart';
import 'package:inject/inject.dart';
import '../models/state.dart';

class Repository {

  final MovieApiProvider _moviesApiProvider;

  @provide
  Repository(this._moviesApiProvider);

  Future<State> fetchAllMovies() => _moviesApiProvider.fetchMovieList();

  Future<State> fetchTrailers(int movieId) => _moviesApiProvider.fetchTrailer(movieId);
}
```

`상태` 를 반환형식에 추가했다. 이것은 성공 혹은 실패 상태를 유지할 것이다.



`movie_bloc.dart` 파일을 열어 아래와 같이 수정하자.

```dart
import '../resources/repository.dart';
import 'package:rxdart/rxdart.dart';
import '../models/item_model.dart';
import '../models/state.dart';
import 'package:inject/inject.dart';
import 'bloc_base.dart';

class MoviesBloc extends BlocBase {
  final Repository _repository;
  PublishSubject<ItemModel> _moviesFetcher;

  @provide
  MoviesBloc(this._repository);

  init() {
    _moviesFetcher = PublishSubject<ItemModel>();
  }

  Observable<ItemModel> get allMovies => _moviesFetcher.stream;

  fetchAllMovies() async {
    State state = await _repository.fetchAllMovies();
    if (state is SuccessState) {
      _moviesFetcher.sink.add(state.value);
    } else if (state is ErrorState) {
      _moviesFetcher.addError(state.msg);
    }
  }

  @override
  dispose() {
    _moviesFetcher.close();
  }
}
```

`fetchAllMovies()` 안에서 `상태` 를 확인하고 stream에게 올바른 데이터를 전달한다.



`movie_detail_bloc.dart` 파일을 열어 아래와 같이 수정하자.

```dart
import 'package:rxdart/rxdart.dart';
import '../models/trailer_model.dart';
import '../resources/repository.dart';
import 'bloc_base.dart';
import 'package:inject/inject.dart';
import '../models/state.dart';

class MovieDetailBloc extends BlocBase {
  final Repository _repository;
  BehaviorSubject<TrailerModel> _trailers;

  Observable<TrailerModel> get movieTrailers => _trailers.stream;

  init() {
    _trailers = BehaviorSubject<TrailerModel>();
  }

  @provide
  MovieDetailBloc(this._repository);

  void fetchTrailersById(id) async {
    final state = await _repository.fetchTrailers(id);
    if (state is SuccessState) {
      _trailers.sink.add(state.value);
    } else {
      _trailers.addError((state as ErrorState).msg);
    }
  }

  @override
  dispose() async {
    await _trailers.drain();
    _trailers.close();
  }
}
```

마찬가지로 `fetchTrailersById()` 에서 같은 작업이 일어난다. `상태` 를 확인하고 적절한 데이터를 stream을 전달한다.



마지막으로 `movie_detail.dart` 를 수정하자.

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import '../blocs/movie_detail_bloc.dart';
import '../models/trailer_model.dart';

class MovieDetail extends StatefulWidget {
  final MovieDetailBloc bloc;
  final String posterUrl;
  final String description;
  final String releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetail(
    this.bloc,
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  );

  @override
  State<StatefulWidget> createState() {
    return MovieDetailState(
      title: title,
      posterUrl: posterUrl,
      description: description,
      releaseDate: releaseDate,
      voteAverage: voteAverage,
      movieId: movieId,
    );
  }
}

class MovieDetailState extends State<MovieDetail> {
  final String posterUrl;
  final String description;
  final String releaseDate;
  final String title;
  final String voteAverage;
  final int movieId;

  MovieDetailState({
    this.title,
    this.posterUrl,
    this.description,
    this.releaseDate,
    this.voteAverage,
    this.movieId,
  });

  @override
  void initState() {
    super.initState();
    widget.bloc.init();
    widget.bloc.fetchTrailersById(movieId);
  }

  @override
  void dispose() {
    widget.bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        top: false,
        bottom: false,
        child: NestedScrollView(
            headerSliverBuilder:
                (BuildContext context, bool innerBoxIsScrolled) {
              return <Widget>[
                SliverAppBar(
                  expandedHeight: 200.0,
                  floating: false,
                  pinned: true,
                  elevation: 0.0,
                  flexibleSpace: FlexibleSpaceBar(
                      background: Image.network(
                    "https://image.tmdb.org/t/p/w500$posterUrl",
                    fit: BoxFit.cover,
                  )),
                ),
              ];
            },
            body: ListView(
              children: <Widget>[
                Padding(
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: <Widget>[
                      Container(margin: EdgeInsets.only(top: 5.0)),
                      Text(
                        title,
                        style: TextStyle(
                          fontSize: 25.0,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Row(
                        children: <Widget>[
                          Icon(
                            Icons.favorite,
                            color: Colors.red,
                          ),
                          Container(
                            margin: EdgeInsets.only(left: 1.0, right: 1.0),
                          ),
                          Text(
                            voteAverage,
                            style: TextStyle(
                              fontSize: 18.0,
                            ),
                          ),
                          Container(
                            margin: EdgeInsets.only(left: 10.0, right: 10.0),
                          ),
                          Text(
                            releaseDate,
                            style: TextStyle(
                              fontSize: 18.0,
                            ),
                          ),
                        ],
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Text(description),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      Text(
                        "Trailer",
                        style: TextStyle(
                          fontSize: 25.0,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Container(margin: EdgeInsets.only(top: 8.0, bottom: 8.0)),
                      StreamBuilder(
                        stream: widget.bloc.movieTrailers,
                        builder: (context,
                            AsyncSnapshot<TrailerModel> snapshot) {
                          if (snapshot.hasData) {
                            if (snapshot.data.results.length > 0)
                              return trailerLayout(snapshot.data);
                            else
                              return noTrailer(snapshot.data);
                          } else {
                            debugPrint("${snapshot.connectionState.toString()}");
                            return Center(child: CircularProgressIndicator());
                          }
                        },
                      ),
                    ],
                  ),
                ),
              ],
            )),
      ),
    );
  }

  Widget noTrailer(TrailerModel data) {
    return Center(
      child: Container(
        child: Text("No trailer available"),
      ),
    );
  }

  Widget trailerLayout(TrailerModel data) {
    if (data.results.length > 1) {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
          trailerItem(data, 1),
        ],
      );
    } else {
      return Row(
        children: <Widget>[
          trailerItem(data, 0),
        ],
      );
    }
  }

  trailerItem(TrailerModel data, int index) {
    return Expanded(
      child: Column(
        children: <Widget>[
          Container(
            margin: EdgeInsets.all(5.0),
            height: 100.0,
            color: Colors.grey,
            child: Center(child: Icon(Icons.play_circle_filled)),
          ),
          Text(
            data.results[index].name,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
}
```

이전에는 네트워크로부터 트레일러를 로드하기 위해서 `FutureBuilder` 을 사용했다. 하지만 이제는 그럴 필요없다. `MobieDetailBloc` 클래스 내의 네트워크에서 JSON 데이터를 가져와 `TrailerModel` 객체로 변환하여 스트림에 추가하기 때문이다. 그래서 이제부터는 `TrailerModel` 객체로 구성된 stream을 직접 관찰할 수 있다.

##### 단위 테스트 케이스 작성

많은 수정이 있었지만, 당신의 코드를 좀 더 명확하게 테스트하는데 분명한 도움이 될 것이다. 아무튼 이제는 단위 테스트 케이스를 작성해보자.

필요한 클래스들의 종속성을 제공해주기 위해 `inject.dart` 프레임워크를 사용하기에, 반드시 단위 테스트를 위한 종속성 그래프를 따로 분리해서 만들어야 한다. 왜냐하면 외부 시스템에 종속되어서는 안되지 때문이다.

`unit_test` 디렉토리안에 아래와 같이 파일들을 만들자.

![Image for post](https://miro.medium.com/max/349/1*yt0NN8otATKpZstqNmaK-g.png)

`mock_client.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'package:mockito/mockito.dart';
import 'package:http/http.dart' as http ;

class MockClient extends Mock implements http.Client {}
```

각 테스트에서 서로 다른 HTTP 응답을 제공하는 `MockClient` 를 만들었다. 단위 테스트의 목적은 최종 기능 요건(final functional requirement)이 아니라 코드의 로직을 검사하는 것이다.



`provider_injector.dart` 파일을 열고 아래 코드를 붙여넣자.

```dart
import 'package:inject/inject.dart';
import 'provider_injector.inject.dart' as g;
import 'provider_module.dart';
import 'provider_test.dart';

@Injector(const [ProviderModule])
abstract class ProviderTestInjector{
  @provide
  ProviderTest get app;

  static final create = g.ProviderTestInjector$Injector.create;
}
```

2번째 줄에서 에러가 나타날 것이다. 하지만 해당 파일은 컴파일 시에 `build_runner` 에 의애 생성될 것이니 걱정하지 말라.



`provider_module.dart` 파일을 열고 아래 코드를 붙여넣자.

```dart
import 'package:inject/inject.dart';
import 'package:my_movies/src/resources/movie_api_provider.dart';
import 'package:http/http.dart' as http;

import 'mock_client.dart';

@module
class ProviderModule{

  @provide
  @singleton
  http.Client client() => MockClient();

  @provide
  @singleton
  MovieApiProvider movieApiProvider(http.Client client) => MovieApiProvider(client);
}
```

12번째 줄을 자세히 보면, `http.Client` 객체가 아니라 `MockClient` 객체를 주입했다. 단위 테스트의 목적은 네트워크 응답을 처리하는 코드를 테스트하기 위한 것이기 때문에 가짜(mock) 객체를 제공한 것이다.



이제 첫 단위 테스트 케이스를 작성해보자. `provider_test.dart` 파일을 열어 아래 코드를 붙여넣자.

```dart
import 'dart:io';
import 'package:inject/inject.dart';
import 'package:mockito/mockito.dart';
import 'package:my_movies/src/resources/movie_api_provider.dart';
import 'package:my_movies/src/models/item_model.dart';
import 'package:my_movies/src/models/trailer_model.dart';
import 'package:my_movies/src/models/state.dart';
import 'provider_injector.dart';
import 'provider_module.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;

void main() {
  group("MovieApiProvider test", () {
    test("fetchMovieList success test", () async {
      var container = await ProviderTestInjector.create(ProviderModule());
      var app = container.app;
      var mockClient = app.mockClient;
      when(mockClient.get(
              "http://api.themoviedb.org/3/movie/popular?api_key=802b2c4b88ea1183e50e6b285a27696e"))
          .thenAnswer((_) async => http.Response(
                  '{"page": 1,"total_results": 19832,"total_pages": 992,"results": [{"vote_count": 302,"id": 420818,"video": false,"vote_average": 6.8,"title": "The Lion King","popularity": 502.676,"poster_path": "/dzBtMocZuJbjLOXvrl4zGYigDzh.jpg","original_language": "en","original_title": "The Lion King","genre_ids": [12,16,10751,18,28],"backdrop_path": "/1TUg5pO1VZ4B0Q1amk3OlXvlpXV.jpg","adult": false,"overview": "Simba idolises his father, King Mufasa, and takes to heart his own royal destiny. But not everyone in the kingdom celebrates the new cub\'s arrival. Scar, Mufasa\'s brother—and former heir to the throne—has plans of his own. The battle for Pride Rock is ravaged with betrayal, tragedy and drama, ultimately resulting in Simba\'s exile. With help from a curious pair of newfound friends, Simba will have to figure out how to grow up and take back what is rightfully his.","release_date": "2019-07-12"}]}',
                  200,
                  headers: {
                    HttpHeaders.contentTypeHeader:
                        'application/json; charset=utf-8'
                  }));
      expect(await app.movieApiProvider.fetchMovieList(),
          isInstanceOf<SuccessState<ItemModel>>());
    });

    test("fetchMovieList fail test", () async {
      var container = await ProviderTestInjector.create(ProviderModule());
      var app = container.app;
      var mockClient = app.mockClient;
      when(mockClient.get(
              "http://api.themoviedb.org/3/movie/popular?api_key=802b2c4b88ea1183e50e6b285a27696e"))
          .thenAnswer((_) async => http.Response(
                  '{"status_code":7,"status_message":"Invalid API key: You must be granted a valid key.","success":false}',
                  401,
                  headers: {
                    HttpHeaders.contentTypeHeader:
                        'application/json; charset=utf-8'
                  }));
      expect(await app.movieApiProvider.fetchMovieList(),
          isInstanceOf<ErrorState>());
    });

    test("fetchTrailer success test", () async {
      var container = await ProviderTestInjector.create(ProviderModule());
      var app = container.app;
      var mockClient = app.mockClient;
      when(mockClient.get(
              "http://api.themoviedb.org/3/movie/420818/videos?api_key=802b2c4b88ea1183e50e6b285a27696e"))
          .thenAnswer((_) async => http.Response(
                  '{"id": 420818,"results": [{"id": "5bf75c2f0e0a26266f0e1e04","iso_639_1": "en","iso_3166_1": "US","key": "4CbLXeGSDxg","name": "The Lion King Official Teaser Trailer","site": "YouTube","size": 1080,"type": "Teaser"}]}',
                  200,
                  headers: {
                    HttpHeaders.contentTypeHeader:
                        'application/json; charset=utf-8'
                  }));
      expect(await app.movieApiProvider.fetchTrailer(420818),
          isInstanceOf<SuccessState<TrailerModel>>());
    });

    test("fetchTrailer fail test", () async {
      var container = await ProviderTestInjector.create(ProviderModule());
      var app = container.app;
      var mockClient = app.mockClient;
      when(mockClient.get(
              "http://api.themoviedb.org/3/movie/428/videos?api_key=802b2c4b88ea1183e50e6b285a27696e"))
          .thenAnswer((_) async => http.Response(
                  '{"id": 428,"results": []}', 401, headers: {
                HttpHeaders.contentTypeHeader: 'application/json; charset=utf-8'
              }));
      expect(await app.movieApiProvider.fetchTrailer(428),
          isInstanceOf<ErrorState>());
    });
  });
}

class ProviderTest {
  final MovieApiProvider movieApiProvider;
  final http.Client mockClient;

  @provide
  ProviderTest(this.movieApiProvider, this.mockClient) : super();
}
```

위의 코드를 하나씩 하나씩 보자.

1. `main()` 메소드는 모든 테스트 케이스를 가지고 있다.
2. `group()` 은 여러 테스트 케이스를 가지는 메소드이다.
3. `test()` 메소드에는 단 하나의 테스트 케이스가 들어있다.  여러 테스트 케이스를 만드려면 여러개의 `test()` 메소드를 선언하고 그 안에 각각의 테스트 케이스를 작성해야한다.
4. `expect()` 는 두개의 파라미터를 가지고 서로 맞는지 틀린지 확인한다. 이부분이 테스트 케이스가 통과하는지 실패하는지 체크하는 부분이다. 위의 코드에서 보면, `expect()` 에 들어가는 첫번째 인자는 실제 받아온 타입이고 두번째 인자는 나와야하는 정답 타입이다.
5. 다른 JSON 내용과 상태코드를 `fetchMovieList()` 와 `fetchTrailer()` 에 보내, 기대하는 상태 값을 제대로 반환하는지 확인한다.

##### 유닛 테스트 실행

최상위 프로젝트를 가르키도록 터미널을 켜고, 아래의 코드를 실행한다.

```
flutter packages pub run build_runner build --delete-conflicting-outputs
```

실행 한 후, `Succeeded` 메세지를 받았다면 모든것이 정상작동 하는 것이다. :clap:

`unit_test` 디렉토리에 `provider_injector_inject.dart` 파일이 추가된 것을 확인할 수 있다. 열어보면 필요한 모든 객체가 생성되고 주입 준비가 되어있는 것을 볼 수 있다. 이제 `provider_test.dart` 에서 오류가 사라졌을 것이다.



`provider_test.dart` 파일로 돌아가서, `main()` 메소드 옆의 녹색 버튼을 클릭하면 다음과 같은 출력을 볼 수 있다.

![Image for post](https://miro.medium.com/max/1395/1*7ftb-mXlxTPTWxdcWovpeg.png)

`MovieApiProvider` 클래스에 API 키를 까먹고 추가하지 않아 테스트 케이스가 실패했다. 만약 제대로 넣었다면 아래와 같은 성공출력을 볼 수 있다.

![Image for post](https://miro.medium.com/max/1275/1*hJhPZynRQFPAlSt9ZE3-uA.png)

예~:clap: :clap: :clap: :clap: 이것으로 모든 단위 테스트 케이스를 성공적으로 실행했다. `fetchMovieList()` 와 `fetchTrailer()` 메소드의 로직을 각기 다른 시나리오로 테스트를 한 것이다.



#### 3. BLoC 통합 테스트

이제 통합 테스트 케이스를 작성하여 개별 모듈이 어떻게 통합되는지 살펴보자.

`integration_test` 디렉토리 아래에 `bloc_test.dart` 파일을 생성하고 아래 코드를 붙여넣자.

```dart
import 'package:inject/inject.dart';
import 'package:my_movies/src/blocs/movies_bloc.dart';
import 'package:my_movies/src/blocs/movie_detail_bloc.dart';
import 'package:my_movies/src/models/item_model.dart';
import 'package:my_movies/src/models/trailer_model.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:my_movies/src/di/bloc_injector.dart';
import 'package:my_movies/src/di/bloc_module.dart';

void main() async {
  group("BloC testing", (){
    test("Movie BLoC testing", () async {
      var container = await BlocInjector.create(BlocModule());
      var moviesBloc = container.app.moviesBloc;
      moviesBloc.init();
      moviesBloc.fetchAllMovies();
      moviesBloc.allMovies.listen(expectAsync1((value){
        expect(value, isInstanceOf<ItemModel>());
      }));
    });
    test("Movie Detail BLoC testing", () async {
      var container = await BlocInjector.create(BlocModule());
      var moviesBloc = container.app.movieDetailBloc;
      moviesBloc.init();
      moviesBloc.fetchTrailersById(420818);
      moviesBloc.movieTrailers.listen(expectAsync1((value){
        expect(value, isInstanceOf<TrailerModel>());
      }));
    });
  });
}
class BlocTest{
  final MoviesBloc moviesBloc;
  final MovieDetailBloc movieDetailBloc;

  @provide
  BlocTest(this.moviesBloc, this.movieDetailBloc): super();

}
```

왜 이것에 대한 종속성 그래프를 따로 만들지 않는지 이유가 궁금할 것이다. 답은 매우 간단하다. 어떠한 가짜(mock) 객체도 제공할 필요가 없기 때문이다. 실제로 네트워크 호출을 하고 *Network Layer, Repository, bloc* 모듈 간의 완전한 통합을 확인하는 중이므로, 실제 프로젝트에서 사용되는 `DI` 모듈을 사용하여 종속성을 제공할 것이다.



#### 4. 테스트 케이스 실행

`main()` 메소드 옆의 녹색 버튼을 클릭하면 다음과 같은 출력을 볼 수 있다.

![Image for post](https://miro.medium.com/max/1290/1*_epHZIEnA_hEBBLQ1DlaZg.png)

이 성공 결과는 *Network Layer, Repository, bloc* 모듈이 올바르게 통합되어 있으며 예상대로 작동하고 있음을 보여준다.















-----

# SQLite 이용하기

> https://dalgonakit.tistory.com/116?category=808568

서드파트 라이브러리 추가**

`pubspec.yaml` 파일의 dependencies 에 추가

```dart
sqflite: ^1.3.1+1
// 버전은 본인이 필요한 버전으로 이용
// https://pub.dev/packages/sqflite
path_provider: ^1.6.18
// https://pub.dev/packages/path_provider
path: ^1.7.0
// https://pub.dev/packages/path
```

추가 후 프로젝트 동기화 (VScode의 경우 저장하면 자동 동기화, 명령어는 `flutter packages get`)

- sqflite : SQLite를 Android와 iOS에 동시에 지원해주는 패키지

- path_finder : Android와 iOS에서 필요한 경로를 알려주는 패키지

  여기서는 db파일을 저장할 위치를 알아내는 용도로 사용

- paht : 경로를 합칠때 사용



**Model 구현**

먼저 강아지를 구분하는 id와 이름을 저장하는 모델을 만듭니다.

`rawInsert, rawDelete, ...` 을 쓰는 것이 아니라 `insert, delete, ...` 를 사용하면 쿼리를 일일히 스트링으로 작성하지 않고, 테이블 이름과 Map 형태의 데이터만 있으면 됩니다.

DogModel을 Map으로 세팅하고 Map으로 추출할 수 있게 만듭니다.

```dart
class Dog {
  final int id;
  final String name;

  Dog({
      this.id,
      this.name
  });

  factory Dog.fromJson(Map<String, dynamic> json) => Dog(
    id: json["id"],
    name: json["name"]
  );

  Map<String, dynamic> toJson() => {
    "id":id,
    "name":name,
  };
```

Dog.fromJson() 생성자를 이용해서 주어진 Map<String, dynamic>을 파라매터 하나씩 매핑 시킵니다 

Dog 인스턴스에서 toJson()함수를 호출 하면 'id' 키에는 id 값을. 'name'키에는 name 값을 대입후 반환 합니다.

> 별도의 패키지 도움 없이 데이터 모델을 입력하면 json 파싱 함수를 만들어주는 사이트가 있습니다. dart 외 여러 언어를 다 지원하니 편하게 사용 합시다.
>
> https://app.quicktype.io/



**Database 헬퍼 구현**

widget코드에서 매번 database를 초기화하고 불러오고 처리하면 너무 안쓰러우니까 Helper 코드를 만들어 보겠습니다

- 최종 코드

`db_helper.dart`

```dart
import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

import 'models/dog_model.dart';

final String TableName = 'Dog';

class DBHelper {

  DBHelper._();
  static final DBHelper _db = DBHelper._();
  // 싱글톤 클래스를 위해 static 변수로 해당 클래스의 인스턴스를 제공
  factory DBHelper() => _db;
  // Factory 를 사용하면 외부에서 클래스 이름으로 접근 가능하게 변경

  static Database _database;

  Future<Database> get database async {
    if(_database != null) return _database;

    _database = await initDB();
    return _database;
  }

  initDB() async {
    Directory documentsDirectory = await getApplicationDocumentsDirectory();
    String path = join(documentsDirectory.path, 'MyDogsDB.db');

    return await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) async {
        await db.execute('''
          CREATE TABLE $TableName(
            id INTEGER PRIMARY KEY,
            name TEXT,
          )
        ''');
          /*SQLITE doesn't have boolean type
        so we store isDone as integer where 0 is false
        and 1 is true*/
      },
      onUpgrade: (db, oldVersion, newVersion){}
    );
  }

  //Create
  createData(Dog dog) async {
    final db = await database;
    var res = await db.insert(TableName, dog.toJson());
    return res;
  }

  //Read
  getDog(int id) async {
    final db = await database;
    var res = await db.query(TableName, where: 'id = ?', whereArgs: [id]);
    return res.isNotEmpty ? Dog.fromJson(res.first) : Null;
  }

  //Read All
  Future<List<Dog>> getAllDogs() async {
    final db = await database;
    var res = await db.query(TableName);
    List<Dog> list = res.isNotEmpty ? res.map((c) => Dog.fromJson(c)).toList() : [];
    return list;
  }

  //Update
  updateDog(Dog dog) async {
    final db = await database;
    var res = db.update(TableName, dog.toJson(), where: 'id = ?', whereArgs: [dog.id]);
    return res;
  }

  //Delete
  deleteDog(int id) async {
    final db = await database;
    var res = db.delete(TableName, where: 'id = ?', whereArgs: [id]);
    return res;
  }

  //Delete All
  deleteAllDogs() async {
    final db = await database;
    db.rawDelete('DELETE FROM $TableName');
  }

}
```

- 데이터베이스 초기화

```dart
final String TableName = 'Dog';

initDB() async {
    Directory documentsDirectory = await getApplicationDocumentsDirectory();
    String path = join(documentsDirectory.path, 'MyDogsDB.db');

    return await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) async {
        await db.execute('''
          CREATE TABLE $TableName(
            id INTEGER PRIMARY KEY,
            name TEXT,
          )
        ''');
      },
      onUpgrade: (db, oldVersion, newVersion){}
    );
  }
```

path_provider에서 지원하는 getApplicationDocumentsDirectory() 함수를 통해서 적당한 위치를 가져오고 경로를 만듭니다.

sqflite에서 지원하는 openDatabase()함수를 이용해서 경로를 불러오고 만약 없다면 onCreate 함수가 실행됩니다. 

테이블을 위에서 알려준 모델과 같은 조건(id, name)으로 만듭니다.

migration이 필요하다면 onUpgrade 함수를 구현하면 됩니다.

- Factory

```dart
class DBHelper {

  DBHelper._();
  static final DBHelper _db = DBHelper._();
  factory DBHelper() => _db;

  static Database _database;

  Future<Database> get database async {
    if(_database != null) return _database;

    _database = await initDB();
    return _database;
  }
}
```

DBHelper 클래스를 불러오기 편하게 하기 위해서 factory로 가져오게 만들었습니다.

그리고 Database를 가져오는 get 키워드를 사용해서 없으면 initDB() 함수를 호출하고 있으면 반환하게 만듭니다

initDB의 내부 과정에서 Database를 가져올때, 파일 접근을 하게 되니 비동기로 Future<Database>로 반환하게 됩니다

- CRUD

이번에는 생성하고(c), 읽고(r), 삭제(d)하는 기능을 만들어봅시다

갱신하는 기능은 다음 목표에서 만들어봅시당

```dart
  //Create
  createData(Dog dog) async {
    final db = await database;
    var res = await db.rawInsert('INSERT INTO $TableName(name) VALUES(?)', [dog.name]);
    return res;
  }

  //Read
  getDog(int id) async {
    final db = await database;
    var res = await db.rawQuery('SELECT * FROM $TableName WHERE id = ?', [id]);
    return res.isNotEmpty ? Dog(id: res.first['id'], name: res.first['name']) : Null;
  }

  //Read All
  Future<List<Dog>> getAllDogs() async {
    final db = await database;
    var res = await db.rawQuery('SELECT * FROM $TableName');
    List<Dog> list = res.isNotEmpty ? res.map((c) => Dog(id:c['id'], name:c['name'])).toList() : [];

    return list;
  }

  //Delete
  deleteDog(int id) async {
    final db = await database;
    var res = db.rawDelete('DELETE FROM $TableName WHERE id = ?', [id]);
    return res;
  }

  //Delete All
  deleteAllDogs() async {
    final db = await database;
    db.rawDelete('DELETE FROM $TableName');
  }
  
  //Update
  updateDog(Dog dog) async {
    final db = await database;
    var res = db.rawUpdate('UPDATE $TableName SET name = ? WHERE = ?', [dog.name, dog.id]);
    return res;
  }
```

database를 호출하고 raw가 포함된 insert, query, delete를 호출하였습니다

문법은 기본적인 SQLite와 같고, 물음표(?)가 들어가는 부분은 뒤에 포함된 파라매터인 배열([ ])의 원소가 치환되는 방식으로 되어 있습니다. 은근 편하더군요.

dart에서는 위에서 사용한 $TableName처럼. 굳이 물음표로 치환하지 않아도 '$변수' 를 이용하거나 '${ }' 방법으로도 대체할 수 있습니다.



**화면 구성**

- 최종 코드

`main.dart`

```dart
import 'package:flutter/material.dart';

import 'sqlite/db_helper.dart';
import 'sqlite/models/dog_model.dart';
import 'dart:math';

// 랜덤 리스트
List<Dog> dogs = [
  Dog(name: '푸들이'),
  Dog(name: '삽살이'),
  Dog(name: '말티말티'),
  Dog(name: '강돌이'),
  Dog(name: '진져'),
  Dog(name: '백구'),
];

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: 'Dog Database'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);

  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      // FutureBuildr 위젯은 비동기 요청을 처리하여 데이터를 표현할 수 있는 위젯
      body: FutureBuilder(
        future: DBHelper().getAllDogs(),
        // snapshot 이 지정된 Future 에서 비동기로 받아온 데이터를 나타냄
        builder: (BuildContext context, AsyncSnapshot<List<Dog>> snapshot) {

          // 데이터의 유무를 확인한다
          if(snapshot.hasData) {
            return ListView.builder(
              itemCount: snapshot.data.length,
              itemBuilder: (BuildContext context, int index) {
                Dog item = snapshot.data[index];
                // Dismissible 위젯은 아이폰 잠금화면에서 볼 수 있는 밀어서 잠금해제 와 같은 위젯
                return Dismissible(
                  key: UniqueKey(),
                  onDismissed: (direction) {
                    DBHelper().deleteDog(item.id);
                  },
                  child: Center(child: Text(item.name)),
                );
              },
            );
          }
          // 데이터가 존재하지 않는다면 LodingIndicator 를 나타남
          else
          {
            return Center(child: CircularProgressIndicator(),);
          }
        },
      ),

      // 전체 삭제와 추가, 새로고침을 위한 FloatingActionButton
      floatingActionButton: Column(
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          FloatingActionButton(
            child: Icon(Icons.refresh),
            onPressed: () {
              DBHelper().deleteAllDogs();
              setState(() {});
            },
          ),
          SizedBox(height: 8.0),
          FloatingActionButton(
            child: Icon(Icons.add),
            onPressed: () {
              Dog dog = dogs[Random().nextInt(dogs.length)];
              DBHelper().createData(dog);
              setState(() {});
            },
          ),
        ],
      )

    );
  }
}
```

- 초기화면

기본적인 화면 구성은 정말 간단합니다. 

리스트 뷰와 플로팅 버튼 2개!

```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: 'Dog Database'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);

  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body:  //리스트가 들어갈 위치
      ,

      floatingActionButton: Column(
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          FloatingActionButton(
            child: Icon(Icons.refresh),
            onPressed: () {
            	//모두 삭제 버튼
            },
          ),
          SizedBox(height: 8.0),
          FloatingActionButton(
            child: Icon(Icons.add),
            onPressed: () {
            	//추가 버튼
            },
          ),
        ],
      )

    );
  }
}
```

App -> MaterialApp -> MyHomePage -> ListView, FloatingActionButtons

자 이제 차근차근 구현해 봅시다

- 추가 버튼 구현

```dart
import 'dart:math';

List<Dog> dogs = [
  Dog(name: '푸들이'),
  Dog(name: '삽살이'),
  Dog(name: '말티말티'),
  Dog(name: '강돌이'),
  Dog(name: '진져'),
  Dog(name: '백구'),
];

...
onPressed: () {
  Dog dog = dogs[Random().nextInt(dogs.length)];
  DBHelper().createData(dog);
  setState(() {});
},         
...
```

이름 입력창을 넣게 되면 복잡해지니까, 미리 이름을 만들어놓았습니다 (푸들이, 삽살이, 말티말티, 강돌이, 진져, 백구~)

버튼을 누를때마다 랜덤하게 가져와서, 데이터베이스에 기록할 수 있게 createData() 함수를 실행 합니다

그리고 statefulWidget이 갱신할 수 있게 setState()함수를 호출 해 줍니다

- 모두 삭제 버튼 구현

```dart
...
onPressed: () {
  DBHelper().deleteAllDogs();
  setState(() {});
},
...
```

모든 삭제는 간단히 DBHelper의 Delete함수를 호출하고

statefulWidget 화면 갱신용 setState()함수를 호출 합니다.

- 리스트 구현

```dart
FutureBuilder(
  future: DBHelper().getAllDogs(),
  builder: (BuildContext context, AsyncSnapshot<List<Dog>> snapshot) {

    if(snapshot.hasData) {
    
      return ListView.builder(
        itemCount: snapshot.data.length,
        itemBuilder: (BuildContext context, int index) {
        
          Dog item = snapshot.data[index];
          
          return Dismissible(
            key: UniqueKey(),
            onDismissed: (direction) {
              DBHelper().deleteDog(item.id);
              setState(() {});
            },
            child: Center(child: Text(item.name)),
          );
        },
      );
    }
    else
    {
      return Center(child: CircularProgressIndicator(),);
    }
  },
),
```

파일 입출력을 하는 Database로 인해 DBHelper().getAllDogs() 함수는 Future로 반환됩니다. 

그렇기 때문에 FutureBuilder를 사용하여 받기로 합니다 

 

데이터를 받을땐 FutureBuilder의 builder 함수로 받아집니다. 

한 순간 받아온 데이터를 snapshot이라 합니다.

snapshot안에 데이터가 있는지 체크하고, 없을때는 로딩(CircularProgressIndicator)을 보여주고

있을때는 당연히 데이터를 리스트형태로 보여줍니다 

 

리스트 형태로 보여줄때는 ListView.builder를 이용하여 Element를 하나씩 그리게 됩니다 

리스트의 각 Element는 Dismissible로 구현합니다

 

Dismissible은 왼쪽 혹은 오른쪽으로 드래그 하였을때 사라지는 기능을 지원하는데,

사라질때 onDismissed함수가 호출됩니다.

이때 실제로 DB에서 사라질 수 있게 DBHelper().deleteDog 함수를 호출해 줍니다.

그 뒤에 화면이 갱신될 수 있게 setState()도 호출해주면 기능 구현도 끝이 납니다.



#### BLOC 적용하기

> https://dalgonakit.tistory.com/117?category=808568

**전체 코드**

모든 BLoC함수를 합치고,

전체 화면을 갱신하는 공통적인 부분은 getDogs() 함수로 변경해주었습니다

```dart
import 'dart:async';
import 'package:flutter_sqlite/sqlite/models/dog_model.dart';
import 'package:flutter_sqlite/sqlite/db_helper.dart';

class DogBloc {

  DogBloc() {
    getDogs();
  }

  final _dogsController = StreamController<List<Dog>>.broadcast();
  get dogs => _dogsController.stream;

  dispose() {
    _dogsController.close();
  }

  getDogs() async {
    _dogsController.sink.add(await DBHelper().getAllDogs());
  }

  addDog(Dog dog) async {
    await DBHelper().createData(dog);
    getDogs();
  }

  deleteDog(int id) async {
    await DBHelper().deleteDog(id);
    getDogs();
  }

  deleteAll() async {
    await DBHelper().deleteAllDogs();
    getDogs();
  }
}
```



**BLoC 클래스 만들기**

`lib/bloc/dog_bloc.dart`

```dart
import 'package:flutter_sqlite/sqlite/models/dog_model.dart';

class DogBloc {

  final _dogsController = StreamController<List<Dog>>.broadcast();
  get dogs => _dogsController.stream;

  dispose() {
    _dogsController.close();
  }
}
```

이전 게시물에서 강아지 목록을 리스트에 전달해서 그리고 있었기 때문에 

BLoC 패턴도 List<Dog> 형태로 작성하였습니다. 

그리고 여러곳에서 받을 수 있도록 broadcast()로 StreamController를 만들었습니다.

(*이 강좌에서는 broadcast가 필요없지요..)

get 키워드를 이용해서 dogController의 stream(출구)을 가져옵니다.



**BLoC 을 메인 화면에 적용**

기존 게시물에서 알려드린 구조는 FutureBuilder에 ListView.builder를 연결하는 방식이였는데 

async로 인해 반환되는 Future형을 받아주는 FutureBuilder보단 StreamController에 맞는 StreamBuilder로 변경하면 됩니다

Builder내부에 있던 future도 stream으로 변경되어서, bloc.dogs(stream)를 할당해 주면 됩니다. 

```dart
class _MyHomePageState extends State<MyHomePage> {

  // Bloc 을 가져옵시다.
  final DogBloc bloc = DogBloc();

  // Stateful Widget 이 dispose 될때 스트림을 닫는다.
  @override void dispose() {
      super.dispose();
      bloc.dispose();
  }
    
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      // FutureBuilder 를 StreamBuilder 로 변경
      body: StreamBuilder(
        stream: bloc.dogs,
        builder: (BuildContext context, AsyncSnapshot<List<Dog>> snapshot) {

          if(snapshot.hasData) {

            return ListView.builder(
              itemCount: snapshot.data.length,
              itemBuilder: (BuildContext context, int index) {

                Dog item = snapshot.data[index];

                return Dismissible(
                  key: UniqueKey(),
                  // 이제 Bloc 을 이용하여 명령을 수행 ...
                  onDismissed: (direction) {
                    bloc.deleteDog(item.id);
                  },
                  child: Center(child: Text(item.name)),
                );
              },
            );
          }
          else
          {
            return Center(child: CircularProgressIndicator(),);
          }
        },
      ),
      ...
    );
  }
}
```



**행동에 따른 화면 출력 구현**

- 플러스 버튼

플러스 버튼을 눌러서 새로운 강아지 정보를 데이터 베이스에 넣고, 새로운 데이터가 있는 데이터베이스를 호출해서 이를 리스트로 반영해야합니다 

아까 BLoC 패턴에서는 입구와 출구가 있다고 했죠? 

입구로는 데이터를 넣어주고, 출구로는 데이터가 빠져 나가는데 *입구에는 어떤 데이터를 넣어줘야 할까요?*

플러스 버튼은 강아지를 새로 추가한단 의미 입니다.

그래서 플러스 버튼을 누르면, 새로운 강아지 정보를 데이터베이스에 기록하고, 기록한 강아지 정보를 입구에 넣어주면 됩니다!

```dart
addDog(Dog dog) async {
  await DBHelper().createData(dog);
  _dogsController.sink.add([dog]); //출구가 리스트를 받아 들어기 때문에 리스트 형태로 넣어줍니다.
}
```

*강아지 추가 함수를 만들고! 강아지를 DB에 넣어 줍니다.*

그리고 입구를 관리하는 StreamController(_dogController)의 입구(sink)에 강아지 배열[]을 넣어 줍니다 



위와 같이 코드를 작성하면 출구에는 어떤 데이터가 나올까요?

당연히 넣어준 dog 데이터만 출구로 나오게 됩니다. 넣어준 dog 데이터만 나오다 보니 화면에는 하나의 데이터만 출력되게 되고, 리스트를 만들려던 우리의 의도와는 많이 멀어지게 됩니다...
그래서 아래코드와 같이 리스트형태로 그려줄 수 있게 sink에 여러개의 데이터를 넣어줍니다

```dart
addDog(Dog dog) async {
  await DBHelper().createData(dog);
  _dogsController.sink.add(await DBHelper().getAllDogs());
}
```

addDog 함수에는 데이터를 1개만 넣었지만, DB에 저장하고, DB에 저장된 모든 강아지 정보를 sink에 넣어줍니다.

이제서야 의도한 대로 플러스를 눌러서 강아지 데이터베이스에 쌓이는걸 볼 수 있습니다

- Dismissible을 이용한 스와이프 삭제

스와이프로 삭제하는 방법은 선택된 강아지 정보를 DB에서 삭제하고,

1) 선택된 강아지 화면만 갱신하는 방법

2) 화면을 초기화 하고, DB에 저장된 모든 강아지 정보를 불러와서 화면에 반영하는 방법이 있습니다



첫 번째 방법은 기존 게시물에서 Dismisible을 이용해서 구현을 했었고

두번째 방법도 물론 기존 게시물에서 구현했지만 BLoC패턴에 맞게 변경해보겠습니다

```dart
import 'dart:async';
import 'package:flutter_sqlite/sqlite/models/dog_model.dart';
import 'package:flutter_sqlite/sqlite/db_helper.dart';

class DogBloc {

  final _dogsController = StreamController<List<Dog>>.broadcast();
  get dogs => _dogsController.stream;

  deleteDog(int id) async {
    await DBHelper().deleteDog(id);
    _dogsController.sink.add(await DBHelper().getAllDogs());
  }

}
```

dog_bloc.dart파일에 deleteDog 함수를 추가하고, DB에서는 id를 기준으로 강아지 정보를 삭제한 다음 DB에 저장된 모든 강아지 정보를 가져와서 sink로 전달합니다

 

main.dart에서는 Dismisible 뷰를 스와이프 하면 deleteDog함수가 호출되게 변경합니다

```dart
Dog item = snapshot.data[index];

return Dismissible(
  key: UniqueKey(),
  onDismissed: (direction) {
    bloc.deleteDog(item.id);
  },
  child: Center(child: Text(item.name)),
);
```

deleteDog 함수가 Dismissible에 의해서 실행되면 삭제 후, sink로 전달된 모든 강아지 정보를 StreamBuilder 가 반응하여 화면을 새로 그려주게 됩니다.

- 전체삭제

새로고침 버튼을 눌러서 전체 삭제를 구현해 봅시다. 

```dart
  deleteAll() async {
    await DBHelper().deleteAllDogs();
    _dogsController.sink.add(await DBHelper().getAllDogs());
  }
```

이전 다른 기능들 처럼 DB에서 삭제후, 모든 데이터를 DB로 부터 호출해서 sink로 넘겨줍니다. 

 

모든 데이터가 삭제 됬다면 모든 데이터를 불러올 필요없이 빈 배열을 넘겨줘도 되지만, 혹시라도 DB 처리 과정에서 오류가 발생되지 않을까하는 염려때문에 sink에는 getAllDogs()를 호출해서 데이터를 넘겨주었습니다 

```dart
FloatingActionButton(
  child: Icon(Icons.refresh),
  onPressed: () {
    bloc.deleteAll();
  },
),
```

main.dart에서는 bloc.deleteAll 함수를 호출하면 간단히 해결됩니다.

- 앱을 종료후 실행에도 데이터 불러오기

지금 코드를 적용후에 앱을 껏다 켜보면, 계속해서 프로그래스바가 돌고 있게 됩니다.

우리가 원하는건 앱을 켰을때 기존에 저장된 데이터가 나와야 되는데 말입니다.

```dart
class DogBloc {

  DogBloc() {
    getDogs();
  }

  final _dogsController = StreamController<List<Dog>>.broadcast();
  get dogs => _dogsController.stream;

  dispose() {
    _dogsController.close();
  }

  getDogs() async {
    _dogsController.sink.add(await DBHelper().getAllDogs());
  }
}
```

생성자에서 데이터를 호출하면 해결됩니다.

생성자에는 async함수를 적용할 수 없어서 별도로 다른 함수(getDogs함수)를 만들어 사용하였습니다



#### DAO 적용하기

> https://medium.com/@vaygeth/reactive-flutter-todo-app-using-bloc-design-pattern-b71e2434f692

**DB_Helper 분리**

` database_provider.dart`

```dart
import 'dart:async';
import 'dart:io';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
final todoTABLE = 'Todo';
class DatabaseProvider {
  static final DatabaseProvider dbProvider = DatabaseProvider();
  Database _database;
  Future<Database> get database async {
    if (_database != null) return _database;
    _database = await createDatabase();
    return _database;
  }
  createDatabase() async {
    Directory documentsDirectory = await getApplicationDocumentsDirectory();
    //"ReactiveTodo.db is our database instance name
    String path = join(documentsDirectory.path, "ReactiveTodo.db");
    var database = await openDatabase(path,
        version: 1, onCreate: initDB, onUpgrade: onUpgrade);
    return database;
  }
  //This is optional, and only used for changing DB schema migrations
  void onUpgrade(Database database, int oldVersion, int newVersion) {
    if (newVersion > oldVersion) {}
  }
  void initDB(Database database, int version) async {
    await database.execute("CREATE TABLE $todoTABLE ("
        "id INTEGER PRIMARY KEY, "
        "description TEXT, "
        /*SQLITE doesn't have boolean type
        so we store isDone as integer where 0 is false
        and 1 is true*/
        "is_done INTEGER "
        ")");
  }
}
```



`dog_dao.dart`

```dart
import 'dart:async';
import 'package:reactive_todo_app/database/database.dart';
import 'package:reactive_todo_app/model/todo.dart';

class TodoDao {
  final dbProvider = DatabaseProvider.dbProvider;

  //Adds new Todo records
  Future<int> createTodo(Todo todo) async {
    final db = await dbProvider.database;
    var result = db.insert(todoTABLE, todo.toDatabaseJson());
    return result;
  }

  //Get All Todo items
  //Searches if query string was passed
  Future<List<Todo>> getTodos({List<String> columns, String query}) async {
    final db = await dbProvider.database;

    List<Map<String, dynamic>> result;
    if (query != null) {
      if (query.isNotEmpty)
        result = await db.query(todoTABLE,
            columns: columns,
            where: 'description LIKE ?',
            whereArgs: ["%$query%"]);
    } else {
      result = await db.query(todoTABLE, columns: columns);
    }

    List<Todo> todos = result.isNotEmpty
        ? result.map((item) => Todo.fromDatabaseJson(item)).toList()
        : [];
    return todos;
  }

  //Update Todo record
  Future<int> updateTodo(Todo todo) async {
    final db = await dbProvider.database;

    var result = await db.update(todoTABLE, todo.toDatabaseJson(),
        where: "id = ?", whereArgs: [todo.id]);

    return result;
  }

  //Delete Todo records
  Future<int> deleteTodo(int id) async {
    final db = await dbProvider.database;
    var result = await db.delete(todoTABLE, where: 'id = ?', whereArgs: [id]);

    return result;
  }

  //We are not going to use this in the demo
  Future deleteAllTodos() async {
    final db = await dbProvider.database;
    var result = await db.delete(
      todoTABLE,
    );

    return result;
  }
}
```



`dog_repository.dart`

```
import 'package:reactive_todo_app/dao/todo_dao.dart';
import 'package:reactive_todo_app/model/todo.dart';

class TodoRepository {
  final todoDao = TodoDao();

  Future getAllTodos({String query}) => todoDao.getTodos(query: query);

  Future insertTodo(Todo todo) => todoDao.createTodo(todo);

  Future updateTodo(Todo todo) => todoDao.updateTodo(todo);

  Future deleteTodoById(int id) => todoDao.deleteTodo(id);

  //We are not going to use this in the demo
  Future deleteAllTodos() => todoDao.deleteAllTodos();
}
```



**BLoC 수정**

```dart
import 'package:reactive_todo_app/model/todo.dart';
import 'package:reactive_todo_app/repository/todo_repository.dart';


import 'dart:async';

class TodoBloc {
  //Get instance of the Repository
  final _todoRepository = TodoRepository();

  //Stream controller is the 'Admin' that manages
  //the state of our stream of data like adding
  //new data, change the state of the stream
  //and broadcast it to observers/subscribers
  final _todoController = StreamController<List<Todo>>.broadcast();

  get todos => _todoController.stream;

  TodoBloc() {
    getTodos();
  }

  getTodos({String query}) async {
    //sink is a way of adding data reactively to the stream
    //by registering a new event
    _todoController.sink.add(await _todoRepository.getAllTodos(query: query));
  }

  addTodo(Todo todo) async {
    await _todoRepository.insertTodo(todo);
    getTodos();
  }

  updateTodo(Todo todo) async {
    await _todoRepository.updateTodo(todo);
    getTodos();
  }

  deleteTodoById(int id) async {
    _todoRepository.deleteTodoById(id);
    getTodos();
  }

  dispose() {
    _todoController.close();
  }
}
```



**UI 수정**

```dart
class HomePage extends StatelessWidget {
  HomePage({Key key, this.title}) : super(key: key);
//Initialize our BLoC
final TodoBloc todoBloc = TodoBloc();
  final String title;
 /*
Too many lines of code not included here, refer back to github repo for the complete code.
*/
                child: Container(
                  //This is where the magic starts
                    child: getTodosWidget()
                ))),
//.... rest of the HomePage class



Widget getTodosWidget() {
  /*The StreamBuilder widget,
  basically this widget will take stream of data (todos)
  and construct the UI (with state) based on the stream
  */
  return StreamBuilder(
    stream: todoBloc.todos,
    builder: (BuildContext context, AsyncSnapshot<List<Todo>> snapshot) {
      return getTodoCardWidget(snapshot);
    },
  );
}
    


Widget getTodoCardWidget(AsyncSnapshot<List<Todo>> snapshot) {
  /*Since most of our operations are asynchronous
  at initial state of the operation there will be no stream
  so we need to handle it if this was the case
  by showing users a processing/loading indicator*/
  if (snapshot.hasData) {
    /*Also handles whenever there's stream
    but returned returned 0 records of Todo from DB.
    If that the case show user that you have empty Todos
    */
    return snapshot.data.length != 0
        ? ListView.builder(
            itemCount: snapshot.data.length,
            itemBuilder: (context, itemPosition) {
              Todo todo = snapshot.data[itemPosition];
              final Widget dismissibleCard = new Dismissible(
                background: Container(
                  child: Padding(
                    padding: EdgeInsets.only(left: 10),
                    child: Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        "Deleting",
                        style: TextStyle(color: Colors.white),
                      ),
                    ),
                  ),
                  color: Colors.redAccent,
                ),
                onDismissed: (direction) {
                  /*The magic
                  delete Todo item by ID whenever
                  the card is dismissed
                  */
                  todoBloc.deleteTodoById(todo.id);
                },
                direction: _dismissDirection,
                key: new ObjectKey(todo),
                child: Card(
                    shape: RoundedRectangleBorder(
                      side: BorderSide(color: Colors.grey[200], width: 0.5),
                      borderRadius: BorderRadius.circular(5),
                    ),
                    color: Colors.white,
                    child: ListTile(
                      leading: InkWell(
                        onTap: () {
                          //Reverse the value
                          todo.isDone = !todo.isDone;
                          /*
                          Another magic.
                          This will update Todo isDone with either
                          completed or not
                          */
                          todoBloc.updateTodo(todo);
                        },
//.... the rest of getTodoCardWidget()
                          
                          
                          
// void _showTodoSearchSheet(BuildContext context){
//... rest of the code
Padding(
  padding: EdgeInsets.only(left: 5, top: 15),
  child: CircleAvatar(
    backgroundColor: Colors.indigoAccent,
    radius: 18,
    child: IconButton(
      icon: Icon(
        Icons.search,
        size: 22,
        color: Colors.white,
      ),
      onPressed: () {
        /*This will get all todos
        that contains similar string
        in the textform
        */
        todoBloc.getTodos(
            query:
                _todoSearchDescriptionFormController
                    .value.text);
        //dismisses the bottomsheet
        Navigator.pop(context);
      },
    ),
  ),
)
                          
                          
                          

                          
                          
import 'package:flutter/material.dart';
import 'package:reactive_todo_app/ui/home_page.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Reactive Flutter',
      theme: ThemeData(
        primarySwatch: Colors.indigo,
        canvasColor: Colors.transparent
      ),
      //Our only screen/page we have
      home: HomePage(title: 'My Todo List'),
    );
  }
}
```







### Fire Store 사용

1. [파이어베이스 연동](https://jk2b.tistory.com/3)

   참고로... ios는 MAC에서만 된다 ㅠㅠ

2. [firebase with BLoC](https://medium.com/codechai/when-firebase-meets-bloc-pattern-fb5c405597e0)

3. https://danielllewellyn.medium.com/flutter-bloc-and-firebase-1f9baee510cf

https://velog.io/@ieed0205/2020.03.21-LEEToday

4. JSON 직렬화 [[공식 문서](https://flutter-ko.dev/docs/development/data-and-backend/json)]

   doc으로 들어와서 map을 내가 직접 할당하는게 아니라, json 직렬화를 통해 바로바로 할당되도록하는것이 좋다.

   이때, 변수명은 doc의 column명과 동일해야한다.

   firebase에 적용하기 [[stackoverflow](https://stackoverflow.com/questions/59295889/firebase-documentsnapshot-map-to-json-object-in-flutter)]



-----

**무거운 에뮬레이터 대신 크롬 웹 이용하기**

VScode 터미널에 명령어 작성하면 웹모드로 실행이 된다.

``` cmd
flutter channel master
flutter upgrade
flutter config --enable-web
flutter create .
flutter run -d chrome
```

(근데 핫리로드가 잘안되는거같은데.. 내가 잘 못쓰는걸까 아니면 웹이 원래 이런걸까?)

:point_right: 웹은 핫 리로드를 지원하지 않기에 재시작을 해줘야한다.

-----

[MyMovie - 현재 플러터를 공부하는데 가장 도움을 많이 받은 원서 (BLOC, DI, UNIT TEST )](https://github.com/SAGARSURI/MyMovies)

[Booil Jung - 두번째로 도움을 많이 받은 번역서](https://booiljung.github.io/technical_articles/flutter/bloc/)

[Flutter 공공 API를 활용한 앱 만들기 응용](https://survivalcoding.com/courses/flutter-api-mvvm/lectures/22494619)

[플러터(Flutter) - VSCode에서 Flutter(플러터) 프로젝트 만들기](https://blog.naver.com/chandong83/221839307790)

[App architecture: MVVM in Flutter using Dart Streams](https://quickbirdstudios.com/blog/mvvm-in-flutter/)

[맨땅에서 Flutter 앱 개발 시작하기 (for windows)](https://velog.io/@jakeseo_me/%EB%A7%A8%EB%95%85%EC%97%90%EC%84%9C-Flutter-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-for-windows-2-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)

[CI/CD for Flutter android app using Github Actions](https://medium.com/@iqan/ci-cd-for-flutter-android-app-using-github-actions-ea065180a3be)





DIO? 상태 클래스 만들기

https://medium.com/flutterdevs/flutter-bloc-for-state-management-using-dio-with-retrofit-ca877463634d





[**플러터(flutter)로 앱만들기 고고 (입문)**](https://www.inflearn.com/course/%ED%94%8C%EB%9F%AC%ED%84%B0-%EC%95%B1%EA%B0%9C%EB%B0%9C-%EC%9E%85%EB%AC%B8?utm_source=mobon&utm_medium=cpm&utm_campaign=icover#curriculum)